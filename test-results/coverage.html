
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>chachacrypt: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">chachacrypt/chachacrypt.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "crypto/rand"
        "errors"
        "flag"
        "fmt"
        "io"
        "log"
        "math/big"
        "os"
        "runtime"
        "strings"
        "sync"

        "golang.org/x/crypto/argon2"
        "golang.org/x/crypto/chacha20poly1305"
        "golang.org/x/term"
)

const (
        defaultSaltSize  = 32
        defaultKeySize   = 32
        defaultKeyTime   = uint32(5)
        defaultKeyMemory = uint32(1024 * 64)
        defaultChunkSize = 1024 * 32
)

// Config holds cryptographic parameters.
type Config struct {
        SaltSize   int
        KeySize    int
        KeyTime    uint32
        KeyMemory  uint32
        KeyThreads uint8
        ChunkSize  int
}

var config Config

// Initialize default cryptographic settings.
func init() <span class="cov0" title="0">{
        config = Config{
                SaltSize:   defaultSaltSize,
                KeySize:    defaultKeySize,
                KeyTime:    defaultKeyTime,
                KeyMemory:  defaultKeyMemory,
                KeyThreads: uint8(runtime.NumCPU()), // Fixed issue with constant uint8 conversion
                ChunkSize:  defaultChunkSize,
        }
}</span>

func main() <span class="cov0" title="0">{
        fmt.Println("Welcome to chachacrypt")

        enc := flag.NewFlagSet("enc", flag.ExitOnError)
        encInput := enc.String("i", "", "Input file to encrypt")
        encOutput := enc.String("o", "", "Output file")

        dec := flag.NewFlagSet("dec", flag.ExitOnError)
        decInput := dec.String("i", "", "Input file to decrypt")
        decOutput := dec.String("o", "", "Output file")

        pw := flag.NewFlagSet("pw", flag.ExitOnError)
        pwSizeFlag := pw.Int("s", 15, "Password length")

        if len(os.Args) &lt; 2 </span><span class="cov0" title="0">{
                showHelp()
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">switch os.Args[1] </span>{
        case "enc":<span class="cov0" title="0">
                _ = enc.Parse(os.Args[2:])
                if err := validateFileInput(*encInput, *encOutput); err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("Input validation error: %v", err)
                }</span>
                <span class="cov0" title="0">if err := encryptFile(*encInput, *encOutput); err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("Encryption failed: %v", err)
                }</span>

        case "dec":<span class="cov0" title="0">
                _ = dec.Parse(os.Args[2:])
                if err := validateFileInput(*decInput, *decOutput); err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("Input validation error: %v", err)
                }</span>
                <span class="cov0" title="0">if err := decryptFile(*decInput, *decOutput); err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("Decryption failed: %v", err)
                }</span>

        case "pw":<span class="cov0" title="0">
                _ = pw.Parse(os.Args[2:])
                fmt.Println("Generated password:", generatePassword(*pwSizeFlag))</span>

        default:<span class="cov0" title="0">
                showHelp()</span>
        }
}

func showHelp() <span class="cov0" title="0">{
        fmt.Println("Usage:")
        fmt.Println("Encrypt a file: chachacrypt enc -i input.txt -o output.enc")
        fmt.Println("Decrypt a file: chachacrypt dec -i input.enc -o output.txt")
        fmt.Println("Generate a password: chachacrypt pw -s 15")
}</span>

func generatePassword(length int) string <span class="cov0" title="0">{
        if length &lt; 12 </span><span class="cov0" title="0">{
                log.Fatal("Password length must be at least 12 characters.")
        }</span>

        <span class="cov0" title="0">characterSets := []string{
                "abcdefghijklmnopqrstuvwxyz",
                "ABCDEFGHIJKLMNOPQRSTUVWXYZ",
                "0123456789",
                "`~!@#$%^&amp;*()_+-={}|[]\\;':\",./&lt;&gt;?",
        }

        var password strings.Builder
        rng := rand.Reader

        for i := 0; i &lt; length; i++ </span><span class="cov0" title="0">{
                setIndex, _ := rand.Int(rng, big.NewInt(int64(len(characterSets))))
                charSet := characterSets[setIndex.Int64()]
                charIndex, _ := rand.Int(rng, big.NewInt(int64(len(charSet))))
                password.WriteByte(charSet[charIndex.Int64()])
        }</span>

        <span class="cov0" title="0">return password.String()</span>
}

func validateFileInput(inputFile, outputFile string) error <span class="cov0" title="0">{
        if inputFile == "" || !fileExists(inputFile) </span><span class="cov0" title="0">{
                return errors.New("provide a valid input file")
        }</span>
        <span class="cov0" title="0">if outputFile == "" </span><span class="cov0" title="0">{
                return errors.New("output file must be provided")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func encryptFile(inputFile, outputFile string) error <span class="cov0" title="0">{
        fmt.Println("Enter a strong password:")
        password := readPassword()

        salt := make([]byte, config.SaltSize)
        if _, err := rand.Read(salt); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error generating salt: %w", err)
        }</span>

        <span class="cov0" title="0">key := argon2.IDKey([]byte(password), salt, config.KeyTime, config.KeyMemory, config.KeyThreads, uint32(config.KeySize))

        in, err := os.Open(inputFile)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error opening input file: %w", err)
        }</span>
        <span class="cov0" title="0">defer in.Close()

        out, err := os.Create(outputFile)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error creating output file: %w", err)
        }</span>
        <span class="cov0" title="0">defer out.Close()

        if _, err := out.Write(salt); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error writing salt: %w", err)
        }</span>

        <span class="cov0" title="0">aead, _ := chacha20poly1305.NewX(key)

        var wg sync.WaitGroup
        buf := make([]byte, config.ChunkSize)

        for </span><span class="cov0" title="0">{
                n, err := in.Read(buf)
                if n == 0 </span><span class="cov0" title="0">{
                        if err == io.EOF </span><span class="cov0" title="0">{
                                break</span>
                        }
                        <span class="cov0" title="0">return fmt.Errorf("error reading input file: %w", err)</span>
                }

                <span class="cov0" title="0">chunk := buf[:n]
                nonce := make([]byte, aead.NonceSize())
                rand.Read(nonce)

                wg.Add(1)
                go func() </span><span class="cov0" title="0">{
                        defer wg.Done()
                        encrypted := aead.Seal(nil, nonce, chunk, nil)
                        out.Write(nonce)
                        out.Write(encrypted)
                }</span>()
        }

        <span class="cov0" title="0">wg.Wait()
        return nil</span>
}

func decryptFile(inputFile, outputFile string) error <span class="cov0" title="0">{
        fmt.Println("Enter the password:")
        password := readPassword()

        in, err := os.Open(inputFile)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error opening input file: %w", err)
        }</span>
        <span class="cov0" title="0">defer in.Close()

        out, err := os.Create(outputFile)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error creating output file: %w", err)
        }</span>
        <span class="cov0" title="0">defer out.Close()

        salt := make([]byte, config.SaltSize)
        if _, err := in.Read(salt); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error reading salt: %w", err)
        }</span>

        <span class="cov0" title="0">key := argon2.IDKey([]byte(password), salt, config.KeyTime, config.KeyMemory, config.KeyThreads, uint32(config.KeySize))
        aead, _ := chacha20poly1305.NewX(key)

        nonceSize := aead.NonceSize()
        buf := make([]byte, config.ChunkSize+nonceSize)

        for </span><span class="cov0" title="0">{
                n, err := in.Read(buf)
                if n == 0 &amp;&amp; err == io.EOF </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">nonce := buf[:nonceSize]
                ciphertext := buf[nonceSize:n]

                plaintext, err := aead.Open(nil, nonce, ciphertext, nil)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("decryption failed: %w", err)
                }</span>
                <span class="cov0" title="0">out.Write(plaintext)</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func readPassword() string <span class="cov0" title="0">{
        password, _ := term.ReadPassword(int(os.Stdin.Fd()))
        fmt.Println()
        return strings.TrimSpace(string(password))
}</span>

func fileExists(filename string) bool <span class="cov0" title="0">{
        _, err := os.Stat(filename)
        return err == nil
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
