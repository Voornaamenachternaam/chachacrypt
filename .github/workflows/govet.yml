name: govet-autofix

on:
  push:
    branches:
      - main
      - 'release/**'
  pull_request:
    branches:
      - main
  workflow_dispatch:
  schedule:
    - cron: '0 2 * * *'

permissions:
  contents: write
  pull-requests: write
  checks: write
  statuses: write

jobs:
  lint-and-autofix:
    name: Lint, Attempt Fixes, Create PR if Needed
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v6
        with:
          fetch-depth: 0
          persist-credentials: true

      - name: Set up Go 1.25.6
        uses: actions/setup-go@v6
        with:
          go-version: '1.25.6'
          cache: false

      - name: Print Go environment
        run: |
          go version
          go env

      - name: Install fieldalignment
        run: |
          set -euo pipefail
          go install golang.org/x/tools/go/analysis/passes/fieldalignment/cmd/fieldalignment@v0.41.0

      - name: Run gofmt (first pass)
        run: |
          set -euo pipefail
          gofmt -s -w . || true

      - name: Run go vet (capture pre-fix logs)
        run: |
          set -euo pipefail
          go vet ./... > "$RUNNER_TEMP/govet-pre.log" 2>&1 || true

      - name: Run fieldalignment (first pass, capture logs)
        run: |
          set -euo pipefail
          fieldalignment -fix ./... > "$RUNNER_TEMP/fieldalignment-pre.log" 2>&1 || true

      - name: Run go mod tidy (first pass)
        run: |
          set -euo pipefail
          go mod tidy || true

      - name: Create and run targeted auto-fixer
        run: |
          set -euo pipefail
          cat > "$RUNNER_TEMP/attempt_autofix.sh" <<'EOF'
#!/usr/bin/env bash
# attempt_autofix.sh - conservative heuristics for repairing common Go syntax blockers
set -euo pipefail
cd "$(git rev-parse --show-toplevel || echo .)"

modified=0
tmpfile="$(mktemp)"
cleanup() { rm -f "$tmpfile"; }
trap cleanup EXIT

# Helper: canonicalize newline endings and remove NULs
clean_file() {
  local f="$1"
  # remove NULs, ensure unix newlines
  if grep -q $'\x00' "$f" >/dev/null 2>&1; then
    tr < "$f" -d '\000' > "$tmpfile" && mv "$tmpfile" "$f"
    modified=1
  fi
}

# Remove merge-conflict blocks: <<<<<<< ... ======= ... >>>>>>>
remove_merge_conflicts() {
  local f="$1"
  if perl -0777 -ne 'print if !/^<<<<<<<.*?\n.*?^=======.*?\n.*?^>>>>>>>.*?\n/ms' "$f" > "$tmpfile" 2>/dev/null; then
    # If file changed (i.e. file had conflict blocks removed), update.
    if ! cmp -s "$tmpfile" "$f"; then
      mv "$tmpfile" "$f"
      modified=1
    fi
  fi
}

# Remove accidental go.mod / toolchain / module headers that may have been injected into a .go file.
strip_mod_like_lines() {
  local f="$1"
  # If file contains a line starting with 'module ' or 'go ' or 'toolchain ' near top, remove contiguous block up to first blank line.
  if awk 'NR<=60 && (/^module[[:space:]]+/ || /^go[[:space:]]+[0-9]/ || /^toolchain[[:space:]]+/ || /^vmodule[[:space:]]+/) { print "YES"; exit }' "$f" | grep -q YES; then
    awk 'BEGIN{skip=0}
      /^module[[:space:]]+/ && skip==0 { skip=1; next }
      /^go[[:space:]]+[0-9]/ && skip==0 { skip=1; next }
      /^toolchain[[:space:]]+/ && skip==0 { skip=1; next }
      /^vmodule[[:space:]]+/ && skip==0 { skip=1; next }
      skip==1 && /^$/ { skip=0; next }
      skip==0 { print }
    ' "$f" > "$tmpfile"
    if ! cmp -s "$f" "$tmpfile"; then
      mv "$tmpfile" "$f"
      modified=1
    fi
  fi
}

# Very conservative text rewrite: fix 'for range n {' -> 'for i := 0; i < n; i++ {' if present.
# Only apply if pattern appears AND file is small (avoid risky mass edits).
fix_for_range_n() {
  local f="$1"
  if grep -qE 'for[[:space:]]+range[[:space:]]+n[[:space:]]*\{' "$f"; then
    # Only apply to files smaller than 100 KB to keep risk low
    if [ "$(stat -c%s "$f")" -le $((100*1024)) ]; then
      perl -0777 -pe 's/\bfor\s+range\s+n\s*\{/for i := 0; i < n; i++ {/g' "$f" > "$tmpfile"
      if ! cmp -s "$f" "$tmpfile"; then
        mv "$tmpfile" "$f"
        modified=1
      fi
    fi
  fi
}

# Remove lines that start with "vmodule " which were observed in your logs
remove_vmodule_lines() {
  local f="$1"
  if grep -q '^vmodule[[:space:]]' "$f" >/dev/null 2>&1; then
    sed -e '/^vmodule[[:space:]]/d' "$f" > "$tmpfile"
    mv "$tmpfile" "$f"
    modified=1
  fi
}

# iterate over .go files (skip vendor)
while IFS= read -r -d '' file; do
  # skip generated files by convention (do not modify)
  case "$file" in
    */vendor/*|*_generated.go|*generated.go) continue ;;
  esac

  # Clean NULs and unify line endings
  clean_file "$file"

  # Remove merge conflict marker blocks
  remove_merge_conflicts "$file"

  # Remove accidental go.mod/module/toolchain/vmodule content injected into .go
  strip_mod_like_lines "$file"
  remove_vmodule_lines "$file"

  # Small targeted rewrite for a known accidental pattern
  fix_for_range_n "$file"

  # Run gofmt on the file to normalize
  if ! gofmt -s -w "$file"; then
    # if gofmt cannot run (syntax errors remain), leave file as-is
    true
  fi
done < <(find . -type f -name '*.go' -print0)

# If we touched anything, stage it for commit (but do not commit)
if [ "$modified" -ne 0 ]; then
  git add -A
  echo "AUTOFIX: staged modified files."
  git --no-pager status --porcelain
  echo "autofix_made_changes=true"
else
  echo "autofix_made_changes=false"
fi

EOF

          chmod +x "$RUNNER_TEMP/attempt_autofix.sh"
          # run the fixer
          "$RUNNER_TEMP/attempt_autofix.sh"
        shell: bash

      - name: Run gofmt (second pass)
        run: |
          set -euo pipefail
          gofmt -s -w . || true

      - name: Run go vet (capture post-fix logs)
        run: |
          set -euo pipefail
          go vet ./... > "$RUNNER_TEMP/govet-post.log" 2>&1 || true

      - name: Run fieldalignment (second pass, capture logs)
        run: |
          set -euo pipefail
          fieldalignment -fix ./... > "$RUNNER_TEMP/fieldalignment-post.log" 2>&1 || true

      - name: Run go mod tidy (second pass)
        run: |
          set -euo pipefail
          go mod tidy || true

      - name: Upload diagnostic logs (pre/post)
        uses: actions/upload-artifact@v6.0.0
        with:
          name: go-diagnostics
          path: |
            ${{ runner.temp }}/govet-pre.log
            ${{ runner.temp }}/fieldalignment-pre.log
            ${{ runner.temp }}/govet-post.log
            ${{ runner.temp }}/fieldalignment-post.log
          if-no-files-found: ignore

      - name: Detect repository changes (staged)
        id: changes
        run: |
          set -euo pipefail
          # we intentionally leave any changes staged (the create-pull-request action will commit them)
          if git diff --cached --quiet; then
            echo "changed=false" >> "$GITHUB_OUTPUT"
          else
            echo "changed=true" >> "$GITHUB_OUTPUT"
          fi

      - name: Create or update Pull Request (if changes)
        if: steps.changes.outputs.changed == 'true'
        uses: peter-evans/create-pull-request@v8
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          branch: auto-fixes/${{ github.run_id }}
          update-existing: true
          commit-message: "chore(autofix): apply safe automatic repairs and formatting [skip ci]"
          title: "[autofix] Apply safe automatic repairs and formatting"
          body: |
            This PR was created automatically if safe repairs were made.

            Actions performed by the workflow:
            - conservative auto-fix heuristics (merge conflict removal, stray go.mod/toolchain lines, null-byte removal, a small set of safe text rewrites)
            - gofmt -s -w
            - fieldalignment -fix (attempted)
            - go mod tidy

            Diagnostic logs (pre/post) are attached as workflow artifacts.

      - name: No auto-fix changes detected
        if: steps.changes.outputs.changed == 'false'
        run: |
          echo "No auto-fixable changes detected; no PR created."
