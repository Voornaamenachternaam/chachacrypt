name: CI

on:
  workflow_dispatch:
  schedule:
    - cron: '0 6 * * *'

permissions:
  contents: write
  pull-requests: write

jobs:
  detect-go:
    name: Detect stable Go versions
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.set-matrix.outputs.matrix }}
    steps:
      - name: Ensure jq is available
        run: |
          set -euo pipefail
          if ! command -v jq >/dev/null 2>&1; then
            export DEBIAN_FRONTEND=noninteractive
            sudo apt-get update -y
            sudo apt-get install -y jq
          fi

      - id: set-matrix
        name: Build Go version matrix (latest stable + up to 2 previous)
        run: |
          set -euo pipefail
          FALLBACK='["1.25","1.24","1.23"]'
          JSON=$(curl -sS 'https://go.dev/dl/?mode=json' || true)
          if [ -z "$JSON" ]; then
            echo "::warning::Failed to fetch go.dev; using fallback matrix"
            echo "matrix=$FALLBACK" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          mapfile -t VERSIONS < <(
            printf '%s\n' "$JSON" \
              | jq -r 'map(select(.stable==true)) | .[].version' \
              | sed 's/^go//' \
              | awk -F. '{print $1"."$2}' \
              | awk '!seen[$0]++'
          )

          ITEMS=()
          for i in 0 1 2; do
            v="${VERSIONS[i]:-}"
            if [ -n "$v" ]; then
              ITEMS+=("\"$v\"")
            fi
          done

          if [ ${#ITEMS[@]} -eq 0 ]; then
            echo "::warning::No stable Go versions parsed; using fallback"
            echo "matrix=$FALLBACK" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          MATRIX_JSON="$(printf '[%s]\n' "$(IFS=,; echo "${ITEMS[*]}")")"
          echo "$MATRIX_JSON" | jq . >/dev/null
          echo "matrix=$MATRIX_JSON" >> "$GITHUB_OUTPUT"

  update-go:
    name: Update Go, dependencies, test, and conditional PR
    needs: detect-go
    runs-on: ubuntu-latest
    timeout-minutes: 120
    strategy:
      fail-fast: false
      matrix:
        go-version: ${{ fromJson(needs.detect-go.outputs.matrix) }}
    env:
      DEFAULT_BRANCH: main
      OPENROUTER_API_KEY: ${{ secrets.OPENROUTER_API_KEY }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v5
        with:
          fetch-depth: 0
          ref: ${{ env.DEFAULT_BRANCH }}

      - name: Setup Go ${{ matrix.go-version }}
        uses: actions/setup-go@v5.5.0
        with:
          go-version: ${{ matrix.go-version }}
          check-latest: true

      - name: Cache Go modules & build cache
        uses: actions/cache@v4
        with:
          path: |
            ~/.cache/go-build
            ~/go/pkg/mod
          key: ${{ runner.os }}-go-${{ matrix.go-version }}-${{ hashFiles('go.sum') }}-${{ github.run_id }}
          restore-keys: |
            ${{ runner.os }}-go-${{ matrix.go-version }}-

      - name: Configure git identity
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"

      - name: Initialize CI state
        run: |
          echo "TEST_EXIT=" >> "$GITHUB_ENV"
          echo "NEW_TEST_EXIT=" >> "$GITHUB_ENV"
          echo "GOSEC_EXIT=" >> "$GITHUB_ENV"

      - name: Determine runtime Go info
        id: go-info
        run: |
          set -euo pipefail
          RUNTIME_FULL=$(go version | awk '{print $3}' | sed 's/^go//')
          RUNTIME_MM=$(printf '%s' "$RUNTIME_FULL" | awk -F. '{print $1"."$2}')
          echo "RUNTIME_FULL=$RUNTIME_FULL" >> "$GITHUB_ENV"
          echo "RUNTIME_MM=$RUNTIME_MM" >> "$GITHUB_ENV"

      - id: safe-go-mod
        name: Safe go.mod update (preserve exact patch if present)
        run: |
          set -euo pipefail
          CURRENT=""
          if [ -f go.mod ]; then
            CURRENT=$(awk '/^go /{print $2; exit}' go.mod || true)
          fi
          RUNTIME_FULL="${RUNTIME_FULL:-$(go version | awk '{print $3}' | sed 's/^go//')}"
          RUNTIME_MM="${RUNTIME_MM:-$(printf '%s' "$RUNTIME_FULL" | awk -F. '{print $1"."$2}')}"
          CHANGED=false
          if [ -z "$CURRENT" ]; then
            echo "go $RUNTIME_MM" >> go.mod
            git add go.mod
            CHANGED=true
          else
            CURRENT_MM=$(printf '%s' "$CURRENT" | awk -F. '{print $1"."$2}')
            if [ "$CURRENT" = "$RUNTIME_FULL" ]; then
              CHANGED=false
            elif [ "$CURRENT_MM" = "$RUNTIME_MM" ]; then
              CHANGED=false
            else
              sed -i -E "s/^go [0-9]+\.[0-9]+(\.[0-9]+)?/go $RUNTIME_MM/" go.mod
              git add go.mod
              CHANGED=true
            fi
          fi
          if [ "$CHANGED" = "true" ]; then
            echo "changed=true" >> "$GITHUB_OUTPUT"
          else
            echo "changed=false" >> "$GITHUB_OUTPUT"
          fi

      - id: compute-upgrades
        name: Compute safe dependency upgrades
        run: |
          set -euo pipefail
          mapfile -t CAND < <(go list -m -u -json all 2>/dev/null | jq -r 'select(.Update) | "\(.Path) \(.Version // "") \(.Update.Version // "")"' || true)
          RUNTIME_MM="${RUNTIME_MM:-$(go version | awk '{print $3}' | sed 's/^go//' | awk -F. '{print $1"."$2}')}"
          num_from_mm() {
            maj=$(echo "$1" | awk -F. '{print $1}')
            min=$(echo "$1" | awk -F. '{print $2+0}')
            echo $((maj * 1000 + min))
          }
          CUR_NUM=$(num_from_mm "$RUNTIME_MM")
          > upgrades.txt
          for L in "${CAND[@]}"; do
            PATH_MOD=$(echo "$L" | awk '{print $1}')
            CURVER=$(echo "$L" | awk '{print $2}')
            UPDVER=$(echo "$L" | awk '{print $3}')
            [ -n "$PATH_MOD" ] || continue
            [ -n "$UPDVER" ] || continue
            CURMAJ=$(echo "${CURVER}" | sed 's/^v//' | cut -d. -f1)
            UPDMAJ=$(echo "${UPDVER}" | sed 's/^v//' | cut -d. -f1)
            if [ "$CURMAJ" != "$UPDMAJ" ]; then
              continue
            fi
            MODJSON=$(go list -m -json "${PATH_MOD}@${UPDVER}" 2>/dev/null || true)
            REQ_GO=$(printf '%s' "$MODJSON" | jq -r '.GoVersion // empty' 2>/dev/null || true)
            if [ -z "$REQ_GO" ]; then
              REQ_GO="1.0"
            fi
            REQ_MM=$(echo "${REQ_GO}" | awk -F. '{print $1"."$2}')
            REQ_NUM=$(num_from_mm "${REQ_MM}")
            if [ "${REQ_NUM}" -gt "${CUR_NUM}" ]; then
              continue
            fi
            echo "${PATH_MOD}@${UPDVER}" >> upgrades.txt
          done
          echo "upgrades_count=$(wc -l < upgrades.txt || echo 0)" >> "$GITHUB_OUTPUT"

      - id: apply-upgrades
        name: Apply safe upgrades
        run: |
          set -euo pipefail
          CHANGED=false
          if [ -s upgrades.txt ]; then
            while IFS= read -r m; do
              [ -n "$m" ] || continue
              go get -u "$m" || echo "::warning::go get failed for $m"
            done < upgrades.txt
            go mod tidy
            git add go.mod go.sum || true
            CHANGED=true
          fi
          if [ "$CHANGED" = "true" ]; then
            echo "changed=true" >> "$GITHUB_OUTPUT"
          else
            echo "changed=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Format & vet
        run: |
          set -euo pipefail
          go fmt ./...
          go vet ./... || true

      - id: run-tests
        name: Run tests (capture output)
        run: |
          set -euo pipefail
          set +e
          go test ./... -timeout 5m 2>&1 | tee test-output.txt
          TEST_EXIT=${PIPESTATUS[0]}
          echo "TEST_EXIT=$TEST_EXIT" >> "$GITHUB_ENV"
          set -e

      - name: Install gosec and run security scan
        run: |
          set -euo pipefail
          export GOBIN="${HOME}/.gobin"
          mkdir -p "$GOBIN"
          export PATH="$GOBIN:$PATH"
          set +e
          go install github.com/securego/gosec/v2/cmd/gosec@latest
          "$GOBIN/gosec" ./... 2>&1 | tee gosec-output.txt || true
          GOSEC_EXIT=${PIPESTATUS[0]}
          echo "GOSEC_EXIT=$GOSEC_EXIT" >> "$GITHUB_ENV"
          set -e

      - name: Attempt conservative auto-fixes when tests failed
        if: ${{ env.TEST_EXIT != '' && env.TEST_EXIT != '0' }}
        run: |
          set -euo pipefail
          go mod tidy || true
          go fmt ./... || true
          set +e
          go test ./... -timeout 5m 2>&1 | tee test-output-after-fix.txt
          NEW_TEST_EXIT=${PIPESTATUS[0]}
          echo "NEW_TEST_EXIT=$NEW_TEST_EXIT" >> "$GITHUB_ENV"
          set -e

      - name: Optionally run AI-assisted repair (last resort)
        if: ${{ env.TEST_EXIT != '' && env.TEST_EXIT != '0' && env.NEW_TEST_EXIT == '' }}
        env:
          OPENROUTER_API_KEY: ${{ secrets.OPENROUTER_API_KEY }}
        run: |
          set -euo pipefail
          if [ -z "${OPENROUTER_API_KEY:-}" ]; then
            exit 0
          fi
          export GOBIN="${HOME}/.gobin"
          mkdir -p "$GOBIN"
          export PATH="$GOBIN:$PATH"
          if ! command -v jq >/dev/null 2>&1; then
            export DEBIAN_FRONTEND=noninteractive
            sudo apt-get update -y
            sudo apt-get install -y jq
          fi
          git fetch origin ${{ env.DEFAULT_BRANCH }} --depth=1 || true
          git diff origin/${{ env.DEFAULT_BRANCH }}...HEAD > repair.diff || true
          head -n 200 test-output.txt > fail-sample.txt || true
          jq -n \
            --arg model "qwen/qwen3-coder:free" \
            --arg system "You are a Go refactoring assistant. Given a small repo diff and failing tests, output a patch (unified diff) that is safe to apply." \
            --arg diff "$(sed -n '1,200p' repair.diff 2>/dev/null || true)" \
            --arg fail "$(sed -n '1,200p' fail-sample.txt 2>/dev/null || true)" \
            '{
              model: $model,
              messages: [
                {role: "system", content: $system},
                {role: "user", content: ("Diff:\n" + $diff + "\n\nFailing tests (first lines):\n" + $fail)}
              ],
              temperature: 0.0,
              max_tokens: 1024
            }' > /tmp/payload.json
          curl -sS https://openrouter.ai/api/v1/chat/completions \
            -H "Authorization: Bearer ${OPENROUTER_API_KEY}" \
            -H "Content-Type: application/json" \
            -d @/tmp/payload.json \
            | jq -r '.choices[0].message.content' > ai-response.txt || true
          PATCH=$(sed -n '/^diff --git /,$p' ai-response.txt || true)
          if [ -n "$PATCH" ]; then
            printf '%s\n' "$PATCH" > ai.patch
            if git apply --check ai.patch 2>/dev/null; then
              git apply ai.patch
              git add -A
              git commit -m "chore(ci): apply AI-assisted test fixes" || true
              echo "applied_ai=true" >> "$GITHUB_OUTPUT"
            fi
          fi

      - name: Upload CI logs
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: ci-logs-${{ matrix.go-version }}
          path: |
            test-output.txt
            test-output-after-fix.txt
            gosec-output.txt
            repair.diff
            ai-response.txt

      - id: commit-changes
        name: Commit any intended changes
        run: |
          set -euo pipefail
          if git diff --quiet; then
            echo "changed=false" >> "$GITHUB_OUTPUT"
            exit 0
          fi
          git add -A
          git commit -m "chore(ci): bump Go/deps for ${{ matrix.go-version }}" || true
          echo "changed=true" >> "$GITHUB_OUTPUT"

      - name: Create Pull Request (only when changes)
        if: ${{ steps.commit-changes.outputs.changed == 'true' }}
        uses: peter-evans/create-pull-request@v7
        with:
          token: ${{ secrets.GH_TOKEN }}
          commit-message: "chore(ci): bump Go to ${{ matrix.go-version }} + deps"
          branch: "ci/auto-update/go-${{ matrix.go-version }}-${{ github.run_id }}"
          base: ${{ env.DEFAULT_BRANCH }}
          title: "chore(ci): Go ${{ matrix.go-version }} + deps"
          body: |
            Automated update:
            - Go runtime: ${{ env.RUNTIME_FULL }}
            - Test exit (before fixes): ${{ env.TEST_EXIT }}
            - Test exit (after fixes): ${{ env.NEW_TEST_EXIT }}
            - Gosec exit: ${{ env.GOSEC_EXIT }}
            - Notes: Only committed intended files (go.mod/go.sum and any applied fixes). Logs were uploaded as artifacts.
          labels: automated

      - name: Final status
        run: |
          if [ "${{ steps.commit-changes.outputs.changed }}" = "true" ]; then
            echo "Pull request created/updated."
          else
            echo "No PR created; no persistent changes required."
          fi
