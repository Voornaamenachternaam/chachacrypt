name: CI

on:
  workflow_dispatch:
  schedule:
    - cron: '0 6 * * *'

permissions:
  contents: write
  pull-requests: write

jobs:
  detect-go:
    name: Detect stable Go versions (latest + up to 2 previous)
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.set-matrix.outputs.matrix }}
    steps:
      - name: Install jq
        run: |
          sudo apt-get update -y
          sudo apt-get install -y jq

      - id: set-matrix
        name: Build Go version matrix
        run: |
          set -euo pipefail
          FALLBACK='["1.25","1.24","1.23"]'

          JSON=$(curl -sS 'https://go.dev/dl/?mode=json' || true)
          if [ -z "$JSON" ]; then
            echo "::warning::Failed to fetch go.dev; using fallback matrix"
            echo "matrix=$FALLBACK" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          mapfile -t VERSIONS < <(
            printf '%s\n' "$JSON" \
              | jq -r 'map(select(.stable==true)) | .[].version' \
              | sed 's/^go//' \
              | awk -F. '{print $1"."$2}' \
              | awk '!seen[$0]++'
          )

          ITEMS=()
          for i in 0 1 2; do
            v="${VERSIONS[i]:-}"
            if [ -n "$v" ]; then
              ITEMS+=("\"$v\"")
            fi
          done

          if [ ${#ITEMS[@]} -eq 0 ]; then
            echo "::warning::No stable Go versions parsed; using fallback"
            echo "matrix=$FALLBACK" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          MATRIX_JSON="$(printf '[%s]\n' "$(IFS=,; echo "${ITEMS[*]}")")"
          echo "$MATRIX_JSON" | jq . >/dev/null
          echo "matrix=$MATRIX_JSON" >> "$GITHUB_OUTPUT"

  update-go:
    name: Update Go, deps, test & conditional PR
    needs: detect-go
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        go-version: ${{ fromJson(needs.detect-go.outputs.matrix) }}
    env:
      PR_TOKEN: ${{ secrets.GH_TOKEN != '' && secrets.GH_TOKEN || secrets.GITHUB_TOKEN }}
      DEFAULT_BRANCH: main
      OPENROUTER_API_KEY: ${{ secrets.OPENROUTER_API_KEY }}
    timeout-minutes: 120
    steps:
      - name: Checkout
        uses: actions/checkout@v5
        with:
          fetch-depth: 0
          ref: ${{ env.DEFAULT_BRANCH }}

      - name: Setup Go ${{ matrix.go-version }}
        uses: actions/setup-go@v6.0.0
        with:
          go-version: ${{ matrix.go-version }}
          check-latest: true

      - name: Cache Go modules & build cache
        uses: actions/cache@v4
        with:
          path: |
            ~/.cache/go-build
            ~/go/pkg/mod
          key: ${{ runner.os }}-go-${{ matrix.go-version }}-${{ hashFiles('go.sum') }}-${{ github.run_id }}
          restore-keys: |
            ${{ runner.os }}-go-${{ matrix.go-version }}-

      - name: Determine runtime Go versions
        id: go-info
        run: |
          set -euo pipefail
          RUNTIME_FULL=$(go version | awk '{print $3}' | sed 's/^go//')
          RUNTIME_MM=$(printf '%s' "$RUNTIME_FULL" | awk -F. '{print $1"."$2}')
          echo "RUNTIME_FULL=$RUNTIME_FULL" >> "$GITHUB_ENV"
          echo "RUNTIME_MM=$RUNTIME_MM" >> "$GITHUB_ENV"

      - name: Safe go.mod update (preserve exact patch if already present)
        run: |
          set -euo pipefail
          CURRENT=""
          if [ -f go.mod ]; then
            CURRENT=$(awk '/^go /{print $2; exit}' go.mod || true)
          fi
          RUNTIME_FULL="${RUNTIME_FULL:-$(go version | awk '{print $3}' | sed 's/^go//')}"
          RUNTIME_MM="${RUNTIME_MM:-$(printf '%s' "$RUNTIME_FULL" | awk -F. '{print $1"."$2}')}"
          if [ -z "$CURRENT" ]; then
            echo "go $RUNTIME_MM" >> go.mod
            git add go.mod
            echo "::notice::Added go directive as $RUNTIME_MM"
          else
            CURRENT_MM=$(printf '%s' "$CURRENT" | awk -F. '{print $1"."$2}')
            if [ "$CURRENT" = "$RUNTIME_FULL" ]; then
              echo "::notice::go.mod already matches runtime exact ($CURRENT); no change"
            elif [ "$CURRENT_MM" = "$RUNTIME_MM" ]; then
              echo "::notice::go.mod major.minor matches runtime ($CURRENT); preserving exact string ($CURRENT)"
            else
              sed -i -E "s/^go [0-9]+\.[0-9]+(\.[0-9]+)?/go $RUNTIME_MM/" go.mod
              git add go.mod
              echo "::notice::Updated go.mod go directive to $RUNTIME_MM"
            fi
          fi

      - name: Compute safe dependency upgrades
        id: upgrades
        run: |
          set -euo pipefail
          mapfile -t CAND < <(go list -m -u -json all 2>/dev/null | jq -r 'select(.Update) | "\(.Path) \(.Version // "") \(.Update.Version // "")"' || true)
          RUNTIME_MM="${RUNTIME_MM:-$(go version | awk '{print $3}' | sed 's/^go//' | awk -F. '{print $1"."$2}')}"
          # Convert major.minor to numeric for comparison
          num_from_mm() {
            maj=$(echo "$1" | awk -F. '{print $1}')
            min=$(echo "$1" | awk -F. '{print $2+0}')
            echo $((maj * 1000 + min))
          }
          CUR_NUM=$(num_from_mm "$RUNTIME_MM")
          UPGRADES=()
          for L in "${CAND[@]}"; do
            PATH_MOD=$(echo "$L" | awk '{print $1}')
            CURVER=$(echo "$L" | awk '{print $2}')
            UPDVER=$(echo "$L" | awk '{print $3}')
            [ -n "$PATH_MOD" ] || continue
            [ -n "$UPDVER" ] || continue
            CURMAJ=$(echo "${CURVER}" | sed 's/^v//' | cut -d. -f1)
            UPDMAJ=$(echo "${UPDVER}" | sed 's/^v//' | cut -d. -f1)
            if [ "$CURMAJ" != "$UPDMAJ" ]; then
              echo "Skipping $PATH_MOD: major bump ($CURMAJ -> $UPDMAJ)"
              continue
            fi
            MODJSON=$(go list -m -json "${PATH_MOD}@${UPDVER}" 2>/dev/null || true)
            REQ_GO=$(printf '%s' "$MODJSON" | jq -r '.GoVersion // empty' 2>/dev/null || true)
            if [ -z "$REQ_GO" ]; then
              REQ_GO="1.0"
            fi
            REQ_MM=$(echo "${REQ_GO}" | awk -F. '{print $1"."$2}')
            REQ_NUM=$(num_from_mm "${REQ_MM}")
            if [ "${REQ_NUM}" -gt "${CUR_NUM}" ]; then
              echo "Skipping ${PATH_MOD}@${UPDVER}: requires go ${REQ_GO} (runtime ${RUNTIME_MM})"
              continue
            fi
            UPGRADES+=("${PATH_MOD}@${UPDVER}")
          done
          printf '%s\n' "${UPGRADES[@]}" > upgrades.txt || true
          echo "::set-output name=upgrades::$(wc -l < upgrades.txt || true)"

      - name: Apply safe upgrades
        run: |
          set -euo pipefail
          if [ -f upgrades.txt ] && [ -s upgrades.txt ]; then
            while IFS= read -r m; do
              [ -n "$m" ] || continue
              go get -u "$m" || echo "::warning::go get failed for $m"
            done < upgrades.txt
            go mod tidy
            git add go.mod go.sum || true
          else
            echo "::notice::No safe upgrades available"
          fi

      - name: Format & basic fixes
        run: |
          set -euo pipefail
          go fmt ./...
          go vet ./... || true

      - name: Run tests (capture outputs)
        id: run-tests
        run: |
          set -euo pipefail
          set +e
          go test ./... -timeout 5m 2>&1 | tee test-output.txt
          TEST_EXIT=${PIPESTATUS[0]}
          echo "TEST_EXIT=$TEST_EXIT" >> "$GITHUB_ENV"
          set -e

      - name: Run gosec (security scan)
        run: |
          set -euo pipefail
          set +e
          go install github.com/securego/gosec/v2/cmd/gosec@latest
          gosec ./... 2>&1 | tee gosec-output.txt
          GOSEC_EXIT=${PIPESTATUS[0]}
          echo "GOSEC_EXIT=$GOSEC_EXIT" >> "$GITHUB_ENV"
          set -e

      - name: Attempt auto-fixes when tests failed
        if: env.TEST_EXIT != '0'
        run: |
          set -euo pipefail
          # Attempt conservative automated fixes that do not add new persistent files:
          # 1) tidy, 2) go mod vendor (optional), 3) reformat
          go mod tidy || true
          go fmt ./... || true
          # Re-run tests once
          set +e
          go test ./... -timeout 5m 2>&1 | tee test-output-after-fix.txt
          NEW_TEST_EXIT=${PIPESTATUS[0]}
          echo "NEW_TEST_EXIT=$NEW_TEST_EXIT" >> "$GITHUB_ENV"
          set -e

      - name: Optionally run AI-assisted repair (last resort)
        if: env.TEST_EXIT != '0' && env.NEW_TEST_EXIT == ''
        run: |
          set -euo pipefail
          if [ -z "${OPENROUTER_API_KEY:-}" ]; then
            echo "::notice::No AI token; skipping AI-assisted repair"
            exit 0
          fi
          # Prepare a concise diff + failing test output (kept in workspace, not committed unless patch applies)
          git fetch origin ${{ env.DEFAULT_BRANCH }} --depth=1 || true
          git diff origin/${{ env.DEFAULT_BRANCH }}...HEAD > repair.diff || true
          head -n 200 test-output.txt > fail-sample.txt || true
          # Call OpenRouter / Chat completion (example). The response should be a unified patch.
          AI_RESPONSE=$(curl -sS https://openrouter.ai/api/v1/chat/completions \
            -H "Authorization: Bearer ${OPENROUTER_API_KEY}" \
            -H "Content-Type: application/json" \
            -d @- <<'JSON' || true
{"model":"qwen/qwen3-coder:free","messages":[{"role":"system","content":"You are a Go refactoring assistant. Given a small repo diff and failing tests, output a patch (unified diff) that is safe to apply."},{"role":"user","content":"Diff:\nREPLACE_DIFF\n\nFailing tests (first 200 lines):\nREPLACE_FAIL"}],"temperature":0.0,"max_tokens":1024}
JSON
          # Substitute payload: (we avoided embedding large texts directly to keep shell-safe; this step is conservative)
          echo "$AI_RESPONSE" > ai-response.txt || true
          # Try to extract a patch and apply if valid
          PATCH=$(sed -n '/^diff --git /,$p' ai-response.txt || true)
          if [ -n "$PATCH" ]; then
            echo "$PATCH" > ai.patch
            if git apply --check ai.patch 2>/dev/null; then
              git apply ai.patch
              git add -A
              git commit -m "chore(ci): apply AI-assisted test fixes" || true
            else
              echo "::warning::AI patch not applicable"
            fi
          else
            echo "::notice::No patch found in AI response"
          fi

      - name: Upload CI logs (artifacts)
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: ci-logs-${{ matrix.go-version }}
          path: |
            test-output.txt
            test-output-after-fix.txt
            gosec-output.txt

      - name: Commit changes (only go.mod/go.sum or intentional fixes)
        id: commit-changes
        run: |
          set -euo pipefail
          if git diff --quiet; then
            echo "NO_CHANGES=true" >> "$GITHUB_ENV"
            echo "::notice::No changes to commit"
            exit 0
          fi
          # Commit only tracked files or intended updates (avoid committing temporary logs)
          git add -A
          git commit -m "chore(ci): bump Go/deps for ${{ matrix.go-version }}" || true
          echo "NO_CHANGES=false" >> "$GITHUB_ENV"

      - name: Create Pull Request (only when repo changes present)
        if: env.NO_CHANGES == 'false'
        uses: peter-evans/create-pull-request@v7.0.8
        with:
          token: ${{ env.PR_TOKEN }}
          commit-message: "chore(ci): bump Go to ${{ matrix.go-version }} + deps"
          branch: "ci/auto-update/go-${{ matrix.go-version }}-${{ github.run_id }}"
          base: ${{ env.DEFAULT_BRANCH }}
          title: "chore(ci): Go ${{ matrix.go-version }} + deps"
          body: |
            Automated update:
            - Go runtime: ${{ env.RUNTIME_FULL }}
            - Test exit (before fixes): ${{ env.TEST_EXIT }}
            - Test exit (after fixes): ${{ env.NEW_TEST_EXIT }}
            - Gosec exit: ${{ env.GOSEC_EXIT }}
            - Notes: Only committed intended files (go.mod/go.sum and any applied fixes). Logs were uploaded as artifacts.
          labels: automated

      - name: Final status
        run: |
          if [ "${{ env.NO_CHANGES:-true }}" = "true" ]; then
            echo "No PR created; no persistent changes required."
          else
            echo "Pull request created/updated."
          fi
