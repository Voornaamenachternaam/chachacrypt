name: CI 4

permissions:
  contents: write
  pull-requests: write

on:
  workflow_dispatch:
  schedule:
    - cron: '0 2 * * *'

env:
  ALLOWED_PATTERNS: |
    *.go
    go.mod
    go.sum
    *.yml
    *.yaml
    *.md
    Dockerfile
    Makefile
    .gitattributes
    .github/**
  NEW_FILE_ALLOWLIST: |
    Makefile
    Dockerfile
    README.md
    LICENSE
    .gitattributes

jobs:
  update-and-test:
    runs-on: ubuntu-latest
    timeout-minutes: 90
    env:
      GH_TOKEN: ${{ secrets.GH_TOKEN }}
      OPENROUTER_API_KEY: ${{ secrets.OPENROUTER_API_KEY }}
    steps:
      - name: Checkout
        uses: actions/checkout@v5
        with:
          fetch-depth: 0
          persist-credentials: true

      - name: Configure git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"

      - name: Determine default branch
        id: default-branch
        run: |
          DEFAULT=$(curl -s -H "Authorization: token ${{ secrets.GH_TOKEN }}" "https://api.github.com/repos/${{ github.repository }}" | jq -r .default_branch)
          if [ -z "$DEFAULT" ] || [ "$DEFAULT" = "null" ]; then
            DEFAULT="main"
          fi
          echo "DEFAULT_BRANCH=$DEFAULT" >> $GITHUB_ENV

      - name: Resolve sanitized Go version
        id: resolve-go
        run: |
          JSON=$(curl -fsSL "https://go.dev/dl/?mode=json")
          RAW=$(echo "$JSON" | jq -r 'map(select(.stable==true))[0].version' 2>/dev/null || true)
          if [ -z "$RAW" ] || [ "$RAW" = "null" ]; then
            RAW="go1.25.0"
          fi
          VER=$(echo "$RAW" | sed -E 's/^go//; s/^([0-9]+\.[0-9]+)(\.[0-9]+)?$/\1\2/; s/^([0-9]+\.[0-9]+)$/\1.0/; s/^([0-9]+\.[0-9]+\.[0-9]+).*/\1/')
          if ! echo "$VER" | grep -Eq '^[0-9]+\.[0-9]+\.[0-9]+$'; then
            VER="1.25.0"
          fi
          echo "SANITIZED_GO=${VER}" >> $GITHUB_ENV

      - name: Create working branch from default
        run: |
          set -euo pipefail
          DEFAULT=${{ env.DEFAULT_BRANCH }}
          git fetch origin "${DEFAULT}"
          SHORT=$(git rev-parse --short=8 HEAD || echo "init")
          WORK_BRANCH="ci/work/go-${{ env.SANITIZED_GO }}-${SHORT}-${{ github.run_id }}"
          git checkout -b "${WORK_BRANCH}" "origin/${DEFAULT}"
          echo "WORK_BRANCH=${WORK_BRANCH}" >> $GITHUB_ENV

      - name: Setup Go
        uses: actions/setup-go@v5.5.0
        with:
          go-version: ${{ env.SANITIZED_GO }}
          check-latest: true

      - name: Update go.mod directive safely
        id: update-gomod
        run: |
          set -euo pipefail
          NEW="${SANITIZED_GO}"
          if [ ! -f go.mod ]; then
            printf "module chachacrypt\n\ngo %s\n" "$NEW" > go.mod
            git add go.mod
            echo "go.mod.updated=true" >> $GITHUB_ENV
            exit 0
          fi
          awk -v v="$NEW" 'BEGIN { replaced=0 } /^go[[:space:]]+[0-9]+\.[0-9]+(\.[0-9]+)?[[:space:]]*$/ { if (!replaced) { print "go " v ; replaced=1; next } } { print } END { if (!replaced) printf("go %s\n", v) }' go.mod > go.mod.tmp
          mv go.mod.tmp go.mod
          if ! go mod tidy; then
            git --no-pager diff -- go.mod || true
            exit 1
          fi
          git add go.mod go.sum || true
          echo "go.mod.updated=true" >> $GITHUB_ENV

      - name: Upgrade dependencies (best-effort) and tidy
        run: |
          set -euo pipefail
          if ! go get -u ./... 2>&1 | tee go-get-output.txt; then
            true
          fi
          go mod tidy
          git add go.mod go.sum || true

      - name: Format & stage
        run: |
          set -euo pipefail
          gofmt -w .
          git add -A

      - name: Run go vet
        id: vet
        run: |
          set +e
          go vet ./... 2>&1 | tee vet-output.txt
          echo "VET_EXIT=$?" >> $GITHUB_ENV
          set -e

      - name: Verify modules
        run: go mod verify

      - name: Run tests
        id: tests
        run: |
          set +e
          go test ./... -v -timeout 5m 2>&1 | tee test-output.txt
          echo "TEST_EXIT=$?" >> $GITHUB_ENV
          set -e

      - name: Run gosec
        id: sec
        run: |
          set +e
          go install github.com/securego/gosec/v2/cmd/gosec@latest
          gosec ./... 2>&1 | tee gosec-output.txt
          echo "GOSEC_EXIT=$?" >> $GITHUB_ENV
          set -e

      - name: Build check
        id: build
        run: |
          set +e
          go build ./... 2>&1 | tee build-output.txt
          echo "BUILD_EXIT=$?" >> $GITHUB_ENV
          set -e

      - name: Truncate logs
        run: |
          head -n 500 vet-output.txt   > vet-trunc.txt  || true
          head -n 500 test-output.txt  > test-trunc.txt || true
          head -n 500 gosec-output.txt > gosec-trunc.txt || true
          head -n 200 build-output.txt > build-trunc.txt || true

      - name: Build AI context
        run: |
          {
            echo "Go: ${SANITIZED_GO}"
            echo "=== vet ===";   cat vet-trunc.txt || true
            echo "=== tests ==="; cat test-trunc.txt || true
            echo "=== gosec ==="; cat gosec-trunc.txt || true
            echo "=== build ==="; cat build-trunc.txt || true
          } > ai-context1.txt

      - name: AI propose fixes
        if: env.OPENROUTER_API_KEY != ''
        id: ai
        run: |
          set -euo pipefail
          jq -nc --arg model "deepseek/deepseek-r1:free" --arg system "You are a senior Go engineer. Fix vet/test/gosec/build issues shown in the context. Return a git-style unified diff only." --arg user "$(jq -Rs . < ai-context1.txt)" '{model:$model, messages:[{role:"system",content:$system},{role:"user",content:$user}],temperature:0.05}' > ai-req.json
          RESP=$(curl -s -X POST https://openrouter.ai/api/v1/chat/completions -H "Content-Type: application/json" -H "Authorization: Bearer $OPENROUTER_API_KEY" -d @ai-req.json || true)
          echo "$RESP" | jq -r '.choices[0].message.content // empty' > ai-raw.txt || true
          sed -n '/^diff --git a\//,$p' ai-raw.txt > fixes.diff || true
          if [ ! -s fixes.diff ]; then
            echo "AI_DIFF_PRODUCED=false" >> $GITHUB_ENV
            exit 0
          fi
          echo "AI_DIFF_PRODUCED=true" >> $GITHUB_ENV
          files=$(sed -n 's/^+++ b\///p' fixes.diff | sed 's/\t.*$//' | sed '/^$/d' | uniq)
          echo "$files" > ai-files.txt
          IFS=$'\n'
          for f in $files; do
            if git ls-files --error-unmatch -- "$f" > /dev/null 2>&1; then
              continue
            fi
            ok=false
            for pat in $(echo "${NEW_FILE_ALLOWLIST}"); do
              if [ "$f" = "$pat" ] || [[ "$f" == ${pat%/}/* ]]; then
                ok=true
                break
              fi
            done
            if [ "$ok" = "false" ]; then
              echo "REJECTED_NEW_FILE=$f" >> $GITHUB_ENV
              exit 1
            fi
          done
          unset IFS
          if git apply --check fixes.diff; then
            git apply --whitespace=fix fixes.diff
            git add -A
            echo "AI_DIFF_APPLIED=true" >> $GITHUB_ENV
          else
            cp fixes.diff fixes-unapplied.diff || true
            echo "AI_DIFF_APPLIED=false" >> $GITHUB_ENV
          fi

      - name: Upload AI diff artifact if unapplied
        if: env.OPENROUTER_API_KEY != '' && env.AI_DIFF_PRODUCED == 'true' && env.AI_DIFF_APPLIED != 'true'
        uses: actions/upload-artifact@v4.6.2
        with:
          name: ai-suggested-fix
          path: fixes-unapplied.diff

      - name: Safety check staged additions
        run: |
          set -euo pipefail
          ADDED=$(git diff --cached --name-only --diff-filter=A || true)
          if [ -z "$ADDED" ]; then
            exit 0
          fi
          IFS=$'\n'
          for f in $ADDED; do
            ok=false
            for pat in $(echo "${NEW_FILE_ALLOWLIST}"); do
              if [ "$f" = "$pat" ] || [[ "$f" == ${pat%/}/* ]]; then
                ok=true
                break
              fi
            done
            if [ "$ok" = "false" ]; then
              echo "Unallowed new file staged: $f"
              git restore --staged "$f" || true
              git checkout -- "$f" || true
              echo "Rejected addition: $f"
              exit 1
            fi
          done
          unset IFS

      - name: Final build & tests
        run: |
          set -euo pipefail
          go build ./...
          go test ./... -v

      - name: Commit & push changes
        id: commit
        run: |
          set -euo pipefail
          if git diff --cached --quiet; then
            echo "CHANGES_PRESENT=false" >> $GITHUB_ENV
            exit 0
          fi
          SHORT=$(git rev-parse --short=8 HEAD || echo "initial")
          PUSH_BRANCH="ci/auto-update/go-${SANITIZED_GO}-${SHORT}-${{ github.run_id }}"
          git checkout -b "${PUSH_BRANCH}"
          git commit -m "chore(ci): bump Go ${SANITIZED_GO}, upgrade deps & apply automated fixes" || true
          git push --set-upstream origin "${PUSH_BRANCH}"
          echo "PUSHED_BRANCH=${PUSH_BRANCH}" >> $GITHUB_ENV
          echo "CHANGES_PRESENT=true" >> $GITHUB_ENV

      - name: Create PR for changes
        if: env.CHANGES_PRESENT == 'true'
        uses: peter-evans/create-pull-request@v7.0.8
        with:
          token: ${{ env.GH_TOKEN }}
          branch: ${{ env.PUSHED_BRANCH }}
          base: ${{ env.DEFAULT_BRANCH }}
          commit-message: "chore(ci): bump Go to ${{ env.SANITIZED_GO }}, upgrade deps & apply automated fixes"
          title: "CI: Go ${{ env.SANITIZED_GO }} + automated fixes"
          body: |
            Automated update
            - Go: ${{ env.SANITIZED_GO }}
            - Vet exit: ${{ env.VET_EXIT }}
            - Test exit: ${{ env.TEST_EXIT }}
            - Gosec exit: ${{ env.GOSEC_EXIT }}
            - Build exit: ${{ env.BUILD_EXIT }}
            - AI diff applied: ${{ env.AI_DIFF_APPLIED || 'false' }}
          labels: automated
          draft: false

      - name: Create PR for AI suggestion if unapplied
        if: env.OPENROUTER_API_KEY != '' && env.AI_DIFF_PRODUCED == 'true' && env.AI_DIFF_APPLIED != 'true'
        uses: peter-evans/create-pull-request@v7.0.8
        with:
          token: ${{ env.GH_TOKEN }}
          branch: "ci/ai-suggestions/go-${{ env.SANITIZED_GO }}-${{ github.run_id }}"
          base: ${{ env.DEFAULT_BRANCH }}
          commit-message: "chore(ci): AI suggested fixes (unapplied) for manual review"
          title: "CI: AI suggested fixes (unapplied) — review required"
          body: |
            The AI produced suggested fixes but they could not be auto-applied. The diff file is available as a workflow artifact named "ai-suggested-fix".
          labels: automated, ai-suggestion
          draft: true

      - name: Upload run artifacts
        if: always()
        uses: actions/upload-artifact@v4.6.2
        with:
          name: ci-logs
          path: |
            vet-output.txt
            test-output.txt
            gosec-output.txt
            build-output.txt
            fixes.diff
            fixes-unapplied.diff
            ai-raw.txt
            ai-context1.txt
          retention-days: 7

      - name: Cleanup
        if: always()
        run: |
          rm -f ai-req.json ai-raw.txt fixes.diff fixes-unapplied.diff ai-context1.txt vet-output.txt test-output.txt gosec-output.txt build-output.txt go-get-output.txt || true
