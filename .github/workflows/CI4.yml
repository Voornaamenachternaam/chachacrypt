name: CI 4

# Permissions needed for creating PRs and pushing branches
permissions:
  contents: write
  pull-requests: write

on:
  workflow_dispatch:
  schedule:
    - cron: '0 2 * * *'

env:
  # Allowed file globs (space-separated). AI diffs that propose changes outside these will be rejected.
  # Adjust if you want to permit other safe files.
  ALLOWED_PATTERNS: |
    *.go
    go.mod
    go.sum
    *.yml
    *.yaml
    *.md
    Dockerfile
    Makefile
    .gitattributes
    .github/**

jobs:
  update-and-test:
    runs-on: ubuntu-latest
    timeout-minutes:  ninety
    env:
      GH_TOKEN: ${{ secrets.GH_TOKEN }}
      OPENROUTER_API_KEY: ${{ secrets.OPENROUTER_API_KEY }}
    steps:
      - name: Checkout repository (full)
        uses: actions/checkout@v5
        with:
          fetch-depth: 0
          persist-credentials: true

      - name: Configure Git user
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"

      - name: Resolve latest stable Go version (sanitized)
        id: resolve-go
        run: |
          set -euo pipefail
          JSON=$(curl -fsSL "https://go.dev/dl/?mode=json")
          RAW=$(echo "$JSON" | jq -r 'map(select(.stable==true))[0].version' 2>/dev/null || true)
          if [ -z "$RAW" ] || [ "$RAW" = "null" ]; then
            echo "Could not determine latest stable Go; defaulting to go1.25.0"
            RAW="go1.25.0"
          fi
          # Normalize to X.Y.Z (drop any extra fields). Example: "go1.25" -> 1.25.0 ; "go1.25.0" -> 1.25.0
          VER=$(echo "$RAW" | sed -E 's/^go//; s/^([0-9]+\.[0-9]+)(\.[0-9]+)?$/\1\2/; s/^([0-9]+\.[0-9]+)$/\1.0/; s/^([0-9]+\.[0-9]+\.[0-9]+).*/\1/')
          if ! echo "$VER" | grep -Eq '^[0-9]+\.[0-9]+\.[0-9]+$'; then
            echo "Sanitization produced invalid format ('$VER'), falling back to 1.25.0"
            VER="1.25.0"
          fi
          echo "SANITIZED_GO=${VER}" >> $GITHUB_ENV
          echo "Sanitized Go version: ${VER}"

      - name: Setup Go
        uses: actions/setup-go@v5.5.0
        with:
          go-version: ${{ env.SANITIZED_GO }}
          check-latest: true

      - name: Print environment
        run: |
          go version
          go env

      - name: Update go.mod 'go' directive safely
        id: update-gomod
        run: |
          set -euo pipefail
          NEW="${SANITIZED_GO}"
          if [ ! -f go.mod ]; then
            printf "module chachacrypt\n\ngo %s\n" "$NEW" > go.mod
            git add go.mod
            echo "go.mod.updated=true" >> $GITHUB_ENV
            exit 0
          fi
          # Replace only the go directive line or append if missing. Use awk to be safe.
          awk -v v="$NEW" '
            BEGIN { replaced=0 }
            /^go[[:space:]]+[0-9]+\.[0-9]+(\.[0-9]+)?[[:space:]]*$/ {
              if (!replaced) { print "go " v ; replaced=1; next }
            }
            { print }
            END { if (!replaced) printf("go %s\n", v) }
          ' go.mod > go.mod.tmp
          mv go.mod.tmp go.mod
          # Validate with go mod tidy (fail if invalid)
          if ! go mod tidy; then
            echo "ERROR: go mod tidy failed after updating go directive"
            git --no-pager diff -- go.mod || true
            exit 1
          fi
          git add go.mod go.sum || true
          echo "go.mod.updated=true" >> $GITHUB_ENV

      - name: Upgrade dependencies (best-effort) and tidy
        run: |
          set -euo pipefail
          # Best-effort upgrade. Don't let noisy 'go get -u' break the run permanently:
          if ! go get -u ./... 2>&1 | tee go-get-output.txt; then
            echo "go get returned non-zero; proceeding to go mod tidy to ensure deterministic go.mod"
          fi
          go mod tidy
          git add go.mod go.sum || true

      - name: Format & stage
        run: |
          set -euo pipefail
          gofmt -w .
          git add -A

      - name: Run go vet (capture)
        id: vet
        run: |
          set +e
          go vet ./... 2>&1 | tee vet-output.txt
          echo "VET_EXIT=$?" >> $GITHUB_ENV
          set -e

      - name: Verify modules
        run: go mod verify

      - name: Run tests (capture)
        id: tests
        run: |
          set +e
          go test ./... -v -timeout 5m 2>&1 | tee test-output.txt
          echo "TEST_EXIT=$?" >> $GITHUB_ENV
          set -e

      - name: Run gosec (capture)
        id: sec
        run: |
          set +e
          go install github.com/securego/gosec/v2/cmd/gosec@latest
          gosec ./... 2>&1 | tee gosec-output.txt
          echo "GOSEC_EXIT=$?" >> $GITHUB_ENV
          set -e

      - name: Build check (capture)
        id: build
        run: |
          set +e
          go build ./... 2>&1 | tee build-output.txt
          echo "BUILD_EXIT=$?" >> $GITHUB_ENV
          set -e

      - name: Truncate logs for AI context (safe)
        run: |
          head -n 500 vet-output.txt   > vet-trunc.txt || true
          head -n 500 test-output.txt  > test-trunc.txt || true
          head -n 500 gosec-output.txt > gosec-trunc.txt || true
          head -n 200 build-output.txt > build-trunc.txt || true

      - name: Build AI context
        run: |
          {
            echo "Go: ${SANITIZED_GO}"
            echo "=== vet ===";   cat vet-trunc.txt || true
            echo "=== tests ==="; cat test-trunc.txt || true
            echo "=== gosec ==="; cat gosec-trunc.txt || true
            echo "=== build ==="; cat build-trunc.txt || true
          } > ai-context1.txt

      - name: AI pass #1 — generate suggested fixes (safe, do NOT auto-apply failing patches)
        if: env.OPENROUTER_API_KEY != ''
        id: ai1
        run: |
          set -euo pipefail
          PROMPT='You are a senior Go engineer. Fix vet errors, failing tests, and gosec issues shown in the user context. Return a git-style unified diff (diff --git a/... b/...) only. Do NOT assume repository files have changed since the run started; prefer small, conservative patches.'
          jq -nc --arg model "deepseek/deepseek-r1:free" \
            --arg system "$PROMPT" \
            --arg user "$(jq -Rs . < ai-context1.txt)" \
            '{model:$model, messages:[{role:"system",content:$system},{role:"user",content:$user}],temperature:0.05}' \
            > ai-req1.json

          RESP=$(curl -s -X POST https://openrouter.ai/api/v1/chat/completions \
            -H "Content-Type: application/json" \
            -H "Authorization: Bearer $OPENROUTER_API_KEY" \
            -d @ai-req1.json || true)

          echo "$RESP" | jq -r '.choices[0].message.content // empty' > ai-raw1.txt || true
          sed -n '/^diff --git a\//,$p' ai-raw1.txt > fixes1.diff || true

          # If no diff, exit gracefully
          if [ ! -s fixes1.diff ]; then
            echo "No AI diff produced."
            echo "AI_DIFF_PRODUCED=false" >> $GITHUB_ENV
            exit 0
          fi

          echo "AI diff produced; validating paths..."
          # Extract list of files modified
          files=$(sed -n 's/^+++ b\///p' fixes1.diff | sed 's/\t.*$//' | sed '/^$/d' | uniq)
          echo "$files" > ai-files.txt
          echo "Files from AI diff:"
          cat ai-files.txt

          # Validate files against ALLOWED_PATTERNS
          IFS=$'\n'
          for f in $files; do
            ok=false
            for pat in $(echo "$ALLOWED_PATTERNS"); do
              case "$f" in
                $pat) ok=true; break;;
              esac
            done
            if [ "$ok" = "false" ]; then
              echo "ERROR: AI wants to change disallowed path: $f"
              echo "Allowed patterns: $ALLOWED_PATTERNS"
              exit 1
            fi
            # Disallow arbitrary extensionless files unless explicit allowlist
            base=$(basename "$f")
            if [[ "$base" != *.* ]]; then
              case "$base" in
                Dockerfile|Makefile|README|LICENSE|.gitattributes) ;;
                *)
                  echo "ERROR: Disallowed creation/modification of extensionless file: $f"
                  exit 1
              esac
            fi
          done
          unset IFS

          # Try a dry-run apply check
          if git apply --check fixes1.diff; then
            echo "Patch applies cleanly; applying..."
            git apply --whitespace=fix fixes1.diff
            git add -A
            echo "AI_DIFF_APPLIED=true" >> $GITHUB_ENV
            echo "AI_DIFF_PRODUCED=true" >> $GITHUB_ENV
          else
            echo "AI patch does NOT apply cleanly to the working tree. WILL NOT auto-apply."
            # Commit the diff file into a suggestions folder and upload as artifact so humans can review/apply it.
            mkdir -p .github/ai-suggestions
            cp fixes1.diff .github/ai-suggestions/fixes1.diff
            git add .github/ai-suggestions/fixes1.diff
            git commit -m "chore(ci): add AI suggested fixes (unapplied) for manual review" || true
            git reset -- .github/ai-suggestions/fixes1.diff || true
            # Upload artifact for review
            echo "Uploading AI diff as artifact for human review."
            # Use actions/upload-artifact in next step (can't call action inline), set flag
            echo "AI_DIFF_APPLIED=false" >> $GITHUB_ENV
            echo "AI_DIFF_PRODUCED=true" >> $GITHUB_ENV
          fi

      - name: Upload AI diff artifact (if AI produced a diff but didn't auto-apply)
        if: env.OPENROUTER_API_KEY != '' && env.AI_DIFF_PRODUCED == 'true' && env.AI_DIFF_APPLIED != 'true'
        uses: actions/upload-artifact@v4
        with:
          name: ai-suggested-fix
          path: fixes1.diff

      - name: Build final check (capture)
        id: final-build
        run: |
          set +e
          go build ./... 2>&1 | tee final-build-output.txt
          echo "FINAL_BUILD_EXIT=$?" >> $GITHUB_ENV
          set -e

      - name: Final tests (must pass before PR)
        run: |
          set -euo pipefail
          go test ./... -v

      - name: Commit & push (if staged changes present)
        id: commit
        run: |
          set -euo pipefail
          # Only proceed if there are staged changes
          if git diff --cached --quiet; then
            echo "No staged changes to commit."
            echo "CHANGES_PRESENT=false" >> $GITHUB_ENV
            exit 0
          fi
          SHORT=$(git rev-parse --short=8 HEAD)
          BRANCH="ci/auto-update/go-${SANITIZED_GO}-${SHORT}-${{ github.run_id }}"
          git checkout -b "$BRANCH"
          git commit -m "chore(ci): bump Go ${SANITIZED_GO}, upgrade deps & apply automated fixes" || true
          git push --set-upstream origin "$BRANCH"
          echo "PUSHED_BRANCH=$BRANCH" >> $GITHUB_ENV
          echo "CHANGES_PRESENT=true" >> $GITHUB_ENV

      - name: Create Pull Request (only if changes present)
        if: env.CHANGES_PRESENT == 'true'
        uses: peter-evans/create-pull-request@v7.0.8
        with:
          token: ${{ env.GH_TOKEN }}
          branch: ${{ env.PUSHED_BRANCH }}
          commit-message: "chore(ci): bump Go to ${{ env.SANITIZED_GO }}, upgrade deps & apply automated fixes"
          title: "CI: Go ${{ env.SANITIZED_GO }} + automated fixes"
          body: |
            Automated results:
            - Go: ${{ env.SANITIZED_GO }}
            - Vet exit: ${{ env.VET_EXIT }}
            - Test exit: ${{ env.TEST_EXIT }}
            - Gosec exit: ${{ env.GOSEC_EXIT }}
            - Build exit: ${{ env.BUILD_EXIT }}
            - AI diff applied: ${{ env.AI_DIFF_APPLIED || 'false' }}
          labels: automated
          draft: false

      - name: Create PR with AI suggestion artifact (if AI produced a diff but didn't apply)
        if: env.OPENROUTER_API_KEY != '' && env.AI_DIFF_PRODUCED == 'true' && env.AI_DIFF_APPLIED != 'true'
        uses: peter-evans/create-pull-request@v7.0.8
        with:
          token: ${{ env.GH_TOKEN }}
          branch: "ci/ai-suggestions/go-${{ env.SANITIZED_GO }}-${{ github.run_id }}"
          commit-message: "chore(ci): AI suggested fixes (unapplied) for manual review"
          title: "CI: AI suggested fixes (unapplied) — review required"
          body: |
            The AI produced suggested fixes but they could not be auto-applied cleanly. The diff file is attached as an artifact in the workflow run:
            - Artifact: ai-suggested-fix
            Please review and apply manually if appropriate.
          labels: automated, ai-suggestion
          draft: true

      - name: Upload run artifacts (always)
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: ci-logs
          path: |
            vet-output.txt
            test-output.txt
            gosec-output.txt
            build-output.txt
            final-build-output.txt
            fixes1.diff
            ai-raw1.txt
            ai-context1.txt
          retention-days: 7

      - name: Cleanup
        if: always()
        run: |
          rm -f ai-req1.json ai-raw1.txt fixes1.diff ai-context1.txt \
                vet-output.txt test-output.txt gosec-output.txt \
                build-output.txt final-build-output.txt go-get-output.txt || true
