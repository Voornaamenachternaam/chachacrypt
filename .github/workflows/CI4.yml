name: CI

on:
  workflow_dispatch:
  schedule:
    - cron: '0 6 * * *'

permissions:
  contents: write
  pull-requests: write

jobs:
  detect-go:
    name: Detect stable Go versions
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.set-matrix.outputs.matrix }}
    steps:
      - name: Ensure jq is available
        run: |
          set -euo pipefail
          if ! command -v jq >/dev/null 2>&1; then
            export DEBIAN_FRONTEND=noninteractive
            sudo apt-get update -y
            sudo apt-get install -y jq
          fi

      - id: set-matrix
        name: Build Go version matrix (latest stable + up to 2 previous)
        run: |
          set -euo pipefail
          FALLBACK='["1.25","1.24","1.23"]'
          JSON=$(curl -sS 'https://go.dev/dl/?mode=json' || true)
          if [ -z "$JSON" ]; then
            echo "matrix=$FALLBACK" >> "$GITHUB_OUTPUT"
            exit 0
          fi
          mapfile -t VERSIONS < <(
            printf '%s\n' "$JSON" \
              | jq -r 'map(select(.stable==true)) | .[].version' \
              | sed 's/^go//' \
              | awk -F. '{print $1"."$2}' \
              | awk '!seen[$0]++'
          )
          ITEMS=()
          for i in 0 1 2; do
            v="${VERSIONS[i]:-}"
            if [ -n "$v" ]; then
              ITEMS+=("\"$v\"")
            fi
          done
          if [ ${#ITEMS[@]} -eq 0 ]; then
            echo "matrix=$FALLBACK" >> "$GITHUB_OUTPUT"
            exit 0
          fi
          MATRIX_JSON="$(printf '[%s]\n' "$(IFS=,; echo "${ITEMS[*]}")")"
          echo "$MATRIX_JSON" | jq . >/dev/null
          echo "matrix=$MATRIX_JSON" >> "$GITHUB_OUTPUT"

  update-go:
    name: Update Go, deps, lint/fix, test, security scan & conditional PR
    needs: detect-go
    runs-on: ubuntu-latest
    timeout-minutes: 150
    strategy:
      fail-fast: false
      matrix:
        go-version: ${{ fromJson(needs.detect-go.outputs.matrix) }}
    env:
      DEFAULT_BRANCH: main
      OPENROUTER_API_KEY: ${{ secrets.OPENROUTER_API_KEY }}
      PR_TOKEN: ${{ secrets.GH_TOKEN }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v5
        with:
          fetch-depth: 0
          ref: ${{ env.DEFAULT_BRANCH }}

      - name: Setup Go ${{ matrix.go-version }}
        uses: actions/setup-go@v6
        with:
          go-version: ${{ matrix.go-version }}
          check-latest: true

      - name: Cache Go modules & build cache
        uses: actions/cache@v4
        with:
          path: |
            ~/.cache/go-build
            ~/go/pkg/mod
          key: ${{ runner.os }}-go-${{ matrix.go-version }}-${{ hashFiles('go.sum') }}-${{ github.run_id }}
          restore-keys: |
            ${{ runner.os }}-go-${{ matrix.go-version }}-

      - name: Configure git identity
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"

      - name: Initialize CI state
        run: |
          echo "TEST_EXIT=" >> "$GITHUB_ENV"
          echo "NEW_TEST_EXIT=" >> "$GITHUB_ENV"
          echo "GOSEC_EXIT=" >> "$GITHUB_ENV"
          echo "LINT_FIXED=false" >> "$GITHUB_ENV"
          echo "SEC_FIXES_APPLIED=false" >> "$GITHUB_ENV"

      - name: Determine runtime Go info
        id: go-info
        run: |
          set -euo pipefail
          RUNTIME_FULL=$(go version | awk '{print $3}' | sed 's/^go//')
          RUNTIME_MM=$(printf '%s' "$RUNTIME_FULL" | awk -F. '{print $1"."$2}')
          echo "RUNTIME_FULL=$RUNTIME_FULL" >> "$GITHUB_ENV"
          echo "RUNTIME_MM=$RUNTIME_MM" >> "$GITHUB_ENV"

      - id: safe-go-mod
        name: Safe go.mod update (preserve exact patch if present)
        run: |
          set -euo pipefail
          CURRENT=""
          if [ -f go.mod ]; then
            CURRENT=$(awk '/^go /{print $2; exit}' go.mod || true)
          fi
          RUNTIME_FULL="${RUNTIME_FULL:-$(go version | awk '{print $3}' | sed 's/^go//')}"
          RUNTIME_MM="${RUNTIME_MM:-$(printf '%s' "$RUNTIME_FULL" | awk -F. '{print $1"."$2}')}"
          CHANGED=false
          if [ -z "$CURRENT" ]; then
            echo "go $RUNTIME_MM" >> go.mod
            git add go.mod
            CHANGED=true
          else
            CURRENT_MM=$(printf '%s' "$CURRENT" | awk -F. '{print $1"."$2}')
            if [ "$CURRENT" = "$RUNTIME_FULL" ]; then
              CHANGED=false
            elif [ "$CURRENT_MM" = "$RUNTIME_MM" ]; then
              CHANGED=false
            else
              sed -i -E "s/^go [0-9]+\.[0-9]+(\.[0-9]+)?/go $RUNTIME_MM/" go.mod
              git add go.mod
              CHANGED=true
            fi
          fi
          if [ "$CHANGED" = "true" ]; then
            echo "changed=true" >> "$GITHUB_OUTPUT"
          else
            echo "changed=false" >> "$GITHUB_OUTPUT"
          fi

      - id: compute-upgrades
        name: Compute safe dependency upgrades
        run: |
          set -euo pipefail
          mapfile -t CAND < <(go list -m -u -json all 2>/dev/null | jq -r 'select(.Update) | "\(.Path) \(.Version // "") \(.Update.Version // "")"' || true)
          RUNTIME_MM="${RUNTIME_MM:-$(go version | awk '{print $3}' | sed 's/^go//' | awk -F. '{print $1"."$2}')}"
          num_from_mm() {
            maj=$(echo "$1" | awk -F. '{print $1}')
            min=$(echo "$1" | awk -F. '{print $2+0}')
            echo $((maj * 1000 + min))
          }
          CUR_NUM=$(num_from_mm "$RUNTIME_MM")
          > upgrades.txt
          for L in "${CAND[@]}"; do
            PATH_MOD=$(echo "$L" | awk '{print $1}')
            CURVER=$(echo "$L" | awk '{print $2}')
            UPDVER=$(echo "$L" | awk '{print $3}')
            [ -n "$PATH_MOD" ] || continue
            [ -n "$UPDVER" ] || continue
            CURMAJ=$(echo "${CURVER}" | sed 's/^v//' | cut -d. -f1 || echo "")
            UPDMAJ=$(echo "${UPDVER}" | sed 's/^v//' | cut -d. -f1 || echo "")
            if [ -n "$CURMAJ" ] && [ -n "$UPDMAJ" ] && [ "$CURMAJ" != "$UPDMAJ" ]; then
              continue
            fi
            MODJSON=$(go list -m -json "${PATH_MOD}@${UPDVER}" 2>/dev/null || true)
            REQ_GO=$(printf '%s' "$MODJSON" | jq -r '.GoVersion // empty' 2>/dev/null || true)
            if [ -z "$REQ_GO" ]; then
              REQ_GO="1.0"
            fi
            REQ_MM=$(echo "${REQ_GO}" | awk -F. '{print $1"."$2}')
            REQ_NUM=$(num_from_mm "${REQ_MM}")
            if [ "${REQ_NUM}" -gt "${CUR_NUM}" ]; then
              continue
            fi
            echo "${PATH_MOD}@${UPDVER}" >> upgrades.txt
          done
          echo "upgrades_count=$(wc -l < upgrades.txt || echo 0)" >> "$GITHUB_OUTPUT"

      - id: apply-upgrades
        name: Apply safe upgrades
        run: |
          set -euo pipefail
          CHANGED=false
          if [ -s upgrades.txt ]; then
            while IFS= read -r m; do
              [ -n "$m" ] || continue
              go get -u "$m" || echo "::warning::go get failed for $m"
            done < upgrades.txt
            go mod tidy
            git add go.mod go.sum || true
            CHANGED=true
          fi
          if [ "$CHANGED" = "true" ]; then
            echo "changed=true" >> "$GITHUB_OUTPUT"
          else
            echo "changed=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Install tooling for automatic fixes
        run: |
          set -euo pipefail
          export GOBIN="${HOME}/.gobin"
          mkdir -p "$GOBIN"
          export PATH="$GOBIN:$PATH"
          go install github.com/golangci/golangci-lint/cmd/golangci-lint@latest
          go install mvdan.cc/gofumpt@latest
          go install golang.org/x/tools/cmd/goimports@latest

      - id: lint-fix
        name: Run automatic linter fixes (golangci-lint --fix, gofumpt, goimports)
        run: |
          set -euo pipefail
          export GOBIN="${HOME}/.gobin"
          export PATH="$GOBIN:$PATH"
          set +e
          golangci-lint run --fix ./... 2>&1 | tee golangci-fix.txt
          RC1=${PIPESTATUS[0]}
          gofumpt -w .
          RC2=$?
          goimports -w .
          RC3=$?
          set -e
          if [ "$RC1" -eq 0 ] && [ "$RC2" -eq 0 ] && [ "$RC3" -eq 0 ]; then
            echo "LINT_FIXED=true" >> "$GITHUB_ENV"
            git add -A
            git commit -m "chore(ci): apply linter automatic fixes" || true
            echo "lint_fixes_applied=true" >> "$GITHUB_OUTPUT"
          else
            echo "LINT_FIXED=false" >> "$GITHUB_ENV"
            echo "lint_fixes_applied=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Run go vet
        run: |
          set -euo pipefail
          go vet ./... 2>&1 | tee vet-output.txt || true

      - id: run-tests
        name: Run tests (capture output)
        run: |
          set -euo pipefail
          set +e
          go test ./... -timeout 5m 2>&1 | tee test-output.txt
          TEST_EXIT=${PIPESTATUS[0]}
          echo "TEST_EXIT=$TEST_EXIT" >> "$GITHUB_ENV"
          set -e

      - name: Install gosec and run security scan (JSON output)
        run: |
          set -euo pipefail
          export GOBIN="${HOME}/.gobin"
          mkdir -p "$GOBIN"
          export PATH="$GOBIN:$PATH"
          go install github.com/securego/gosec/v2/cmd/gosec@latest
          "$GOBIN/gosec" -fmt=json -out=gosec-report.json ./... || true
          cat gosec-report.json || true
          GOSEC_EXIT=0
          if [ -s gosec-report.json ]; then
            ISSUES=$(jq '.issues | length' gosec-report.json 2>/dev/null || echo 0)
            if [ "$ISSUES" -gt 0 ]; then
              GOSEC_EXIT=1
            fi
          fi
          echo "GOSEC_EXIT=$GOSEC_EXIT" >> "$GITHUB_ENV"

      - name: Attempt conservative auto-fixes for G115 (integer cast overflow)
        if: ${{ env.GOSEC_EXIT == '1' }}
        run: |
          set -euo pipefail
          FOUND=$(jq -r '.issues[] | select(.rule_id=="G115") | "\(.file):\(.line)"' gosec-report.json 2>/dev/null || true)
          if [ -z "$FOUND" ]; then
            exit 0
          fi
          TMPDIR=$(mktemp -d)
          APPLIED=0
          while IFS= read -r entry; do
            file=$(echo "$entry" | cut -d: -f1)
            line=$(echo "$entry" | cut -d: -f2)
            [ -f "$file" ] || continue
            code_line=$(sed -n "${line}p" "$file" 2>/dev/null || true)
            if [ -z "$code_line" ]; then
              continue
            fi
            if echo "$code_line" | grep -q -E 'uint(8|16|32|64)\s*\('; then
              expr=$(echo "$code_line" | sed -E 's/.*uint[0-9]+\s*\((.*)\).*/\1/')
              uintbits=$(echo "$code_line" | sed -n 's/.*uint\([0-9]\+\).*/\1/p')
              case "$uintbits" in
                8) MAX=255;;
                16) MAX=65535;;
                32) MAX=4294967295;;
                64) MAX=18446744073709551615;;
                *) MAX=0;;
              esac
              [ "$MAX" -eq 0 ] && continue
              head_file="$TMPDIR/head"
              tail_file="$TMPDIR/tail"
              sed -n '1,'"$(($line-1))"p" "$file" > "$head_file"
              sed -n "$line",'$p' "$file" > "$tail_file"
              guard_file="$TMPDIR/guard"
              cat > "$guard_file" <<'GUARD'
/* inserted by CI: prevent integer cast overflow; review changes */
if <EXPR> < 0 || <EXPR> > <MAX> {
	// handle out-of-range value: return or clamp depending on project policy
	<EXPR> = <MAX>
}
GUARD
              sed -e "s|<EXPR>|$expr|g" -e "s|<MAX>|$MAX|g" "$guard_file" > "$TMPDIR/guard_filled"
              cat "$head_file" "$TMPDIR/guard_filled" "$tail_file" > "$TMPDIR/newfile"
              diff -u "$file" "$TMPDIR/newfile" > "$TMPDIR/diff.patch" || true
              if [ -s "$TMPDIR/diff.patch" ]; then
                if git apply --check "$TMPDIR/diff.patch" 2>/dev/null; then
                  git apply "$TMPDIR/diff.patch"
                  APPLIED=$((APPLIED+1))
                fi
              fi
            fi
          done <<< "$FOUND"
          if [ "$APPLIED" -gt 0 ]; then
            git add -A
            git commit -m "chore(ci): apply conservative guards for gosec G115 findings (automated)" || true
            echo "SEC_FIXES_APPLIED=true" >> "$GITHUB_ENV"
          fi

      - name: Optionally run AI-assisted repair (last resort)
        if: ${{ env.TEST_EXIT != '' && env.TEST_EXIT != '0' && env.NEW_TEST_EXIT == '' }}
        env:
          OPENROUTER_API_KEY: ${{ secrets.OPENROUTER_API_KEY }}
        run: |
          set -euo pipefail
          if [ -z "${OPENROUTER_API_KEY:-}" ]; then
            exit 0
          fi
          export GOBIN="${HOME}/.gobin"
          mkdir -p "$GOBIN"
          export PATH="$GOBIN:$PATH"
          if ! command -v jq >/dev/null 2>&1; then
            export DEBIAN_FRONTEND=noninteractive
            sudo apt-get update -y
            sudo apt-get install -y jq
          fi
          git fetch origin ${{ env.DEFAULT_BRANCH }} --depth=1 || true
          git diff origin/${{ env.DEFAULT_BRANCH }}...HEAD > repair.diff || true
          head -n 200 test-output.txt > fail-sample.txt || true
          jq -n \
            --arg model "qwen/qwen3-coder:free" \
            --arg system "You are a Go refactoring assistant. Given a small repo diff and failing tests, output a patch (unified diff) that is safe to apply. Prefer minimal, well-typed changes and include guards for integer casts." \
            --arg diff "$(sed -n '1,200p' repair.diff 2>/dev/null || true)" \
            --arg fail "$(sed -n '1,200p' fail-sample.txt 2>/dev/null || true)" \
            '{
              model: $model,
              messages: [
                {role: "system", content: $system},
                {role: "user", content: ("Diff:\n" + $diff + "\n\nFailing tests (first lines):\n" + $fail)}
              ],
              temperature: 0.0,
              max_tokens: 1024
            }' > /tmp/payload.json
          curl -sS https://openrouter.ai/api/v1/chat/completions \
            -H "Authorization: Bearer ${OPENROUTER_API_KEY}" \
            -H "Content-Type: application/json" \
            -d @/tmp/payload.json \
            | jq -r '.choices[0].message.content' > ai-response.txt || true
          PATCH=$(sed -n '/^diff --git /,$p' ai-response.txt || true)
          if [ -n "$PATCH" ]; then
            printf '%s\n' "$PATCH" > ai.patch
            if git apply --check ai.patch 2>/dev/null; then
              git apply ai.patch
              git add -A
              git commit -m "chore(ci): apply AI-assisted test fixes (automated)" || true
            fi
          fi

      - id: rerun-tests
        name: Re-run tests if prior failure or fixes applied
        if: ${{ env.TEST_EXIT != '0' || env.LINT_FIXED == 'true' || env.SEC_FIXES_APPLIED == 'true' }}
        run: |
          set -euo pipefail
          set +e
          go test ./... -timeout 5m 2>&1 | tee test-rerun.txt
          NEW_TEST_EXIT=${PIPESTATUS[0]}
          echo "NEW_TEST_EXIT=$NEW_TEST_EXIT" >> "$GITHUB_ENV"
          set -e

      - name: Create or update PR with all applied fixes
        if: ${{ steps.safe-go-mod.outputs.changed == 'true' || steps.apply-upgrades.outputs.changed == 'true' || steps.lint-fix.outputs.lint_fixes_applied == 'true' || env.SEC_FIXES_APPLIED == 'true' }}
        uses: peter-evans/create-pull-request@v7
        with:
          token: ${{ secrets.GH_TOKEN }}
          commit-message: "chore(ci): automated Go updates, linter/security fixes"
          branch: "ci/go-update-${{ matrix.go-version }}"
          title: "chore(ci): Automated updates & fixes for Go ${{ matrix.go-version }}"
          base: ${{ env.DEFAULT_BRANCH }}
          delete-branch: true
