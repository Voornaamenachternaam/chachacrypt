name: CI 4

permissions:
  contents: write
  pull-requests: write

on:
  workflow_dispatch:
  schedule:
    - cron: '0 2 * * *'

env:
  # Files that AI or scripts are allowed to modify (glob-like checks are enforced in the script)
  # You can add to this list if you expect safe files to be created by automation.
  ALLOWED_PATTERNS: |
    *.go
    go.mod
    go.sum
    *.yml
    *.yaml
    *.md
    Dockerfile
    Makefile
    .gitattributes
    .github/**

jobs:
  update-and-test:
    runs-on: ubuntu-latest
    env:
      OPENROUTER_API_KEY: ${{ secrets.OPENROUTER_API_KEY }}
      GH_TOKEN: ${{ secrets.GH_TOKEN }}
    steps:
      - name: Checkout repository (full history)
        uses: actions/checkout@v5
        with:
          fetch-depth: 0
          persist-credentials: true

      - name: Configure git user
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"

      - name: Resolve latest stable Go version
        id: go-version
        run: |
          # Get the latest stable Go version (without the "go" prefix)
          JSON=$(curl -fsSL "https://go.dev/dl/?mode=json")
          LATEST=$(echo "$JSON" | jq -r 'map(select(.stable==true))[0].version' | sed 's/^go//')
          # Fallback if jq or curl fails (should not happen in hosted runner)
          if [ -z "$LATEST" ] || [ "$LATEST" = "null" ]; then
            echo "Could not determine latest Go; defaulting to 1.25.0"
            LATEST="1.25.0"
          fi
          echo "LATEST=${LATEST}" >> $GITHUB_ENV
          echo "Latest Go: ${LATEST}"
      - name: Set up Go ${{ env.LATEST }}
        uses: actions/setup-go@v5.5.0
        with:
          go-version: ${{ env.LATEST }}
          check-latest: true

      - name: Print Go info
        run: |
          go version
          go env

      - name: Update go.mod go directive
        run: |
          # Replace the first "go N.N" line with the latest.
          if grep -qE '^go [0-9]+\.[0-9]+' go.mod; then
            sed -i -E "s/^go [0-9]+\.[0-9]+/go ${{ env.LATEST }}/" go.mod
          else
            echo "go ${{ env.LATEST }}" >> go.mod
          fi
          git add go.mod || true

      - name: Upgrade dependencies & tidy
        run: |
          # Upgrade modules; keep as best-effort but fail early if module system has issues
          # You can pin specific modules here if desired.
          set -o pipefail
          go get -u ./... || true
          go mod tidy

      - name: Format code
        run: |
          gofmt -w .
          # stage any formatting changes so they can be included
          git add -A

      - name: Run go vet (capture output)
        id: vet
        run: |
          set +e
          go vet ./... 2>&1 | tee vet-output.txt
          echo "VET_FAILED=$?" >> $GITHUB_ENV
          set -e

      - name: Verify modules
        run: go mod verify

      - name: Run tests (capture output)
        id: tests
        run: |
          set +e
          go test ./... -v -timeout 5m 2>&1 | tee test-output.txt
          echo "TEST_FAILED=$?" >> $GITHUB_ENV
          set -e

      - name: Run gosec (capture output)
        id: sec
        run: |
          set +e
          # Pin gosec if you want: @2.13.0 (example)
          go install github.com/securego/gosec/v2/cmd/gosec@latest
          gosec ./... 2>&1 | tee gosec-output.txt
          echo "SEC_FAILED=$?" >> $GITHUB_ENV
          set -e

      - name: Truncate logs for AI context
        run: |
          head -n 500 vet-output.txt    > vet-trunc.txt || true
          head -n 500 test-output.txt   > test-trunc.txt || true
          head -n 500 gosec-output.txt  > gosec-trunc.txt || true

      - name: Build AI context #1
        run: |
          {
            echo "Go version: ${{ env.LATEST }}"
            echo "=== vet ===";   cat vet-trunc.txt || true
            echo "=== tests ==="; cat test-trunc.txt || true
            echo "=== gosec ==="; cat gosec-trunc.txt || true
          } > ai-context1.txt

      - name: AI pass #1 – propose fixes (optional)
        if: env.OPENROUTER_API_KEY != ''
        run: |
          # This step asks the AI for diffs that fix vet/tests/gosec.
          # We treat the AI output as untrusted and validate it thoroughly before applying.
          PROMPT='You are a senior Go engineer. Fix vet errors, failing tests, and gosec issues shown in the user context. Return a git-style unified diff where file paths are exact (e.g. diff --git a/path/to/file.go b/path/to/file.go).'
          jq -nc --arg model "deepseek/deepseek-r1:free" \
            --arg system "$PROMPT" \
            --arg user "$(jq -Rs . < ai-context1.txt)" \
            '{model:$model, messages:[{role:"system",content:$system},{role:"user",content:$user}],temperature:0.1}' \
            > ai-req1.json

          # Send to AI
          RESP=$(curl -s -X POST https://openrouter.ai/api/v1/chat/completions \
            -H "Content-Type: application/json" \
            -H "Authorization: Bearer $OPENROUTER_API_KEY" \
            -d @ai-req1.json || true)

          echo "$RESP" | jq -r '.choices[0].message.content // empty' > ai-raw1.txt || true

          # Extract only the first git-style diff block(s)
          # This greedy sed extracts from first "diff --git a/" to end of file.
          sed -n '/^diff --git a\//,$p' ai-raw1.txt > fixes1.diff || true

          # If diff non-empty, validate candidate files before applying
          if [ -s fixes1.diff ]; then
            echo "AI produced a diff; validating changed file paths..."
            # Extract target file paths (+++ b/...)
            files=$(sed -n 's/^+++ b\///p' fixes1.diff | sed 's/\t.*$//g' | sed '/^$/d' | uniq)
            echo "Files proposed by AI:"
            echo "$files"

            # Allowed patterns (from env.ALLOWED_PATTERNS)
            IFS=$'\n'
            for f in $files; do
              ok=false
              for pat in $(echo "$ALLOWED_PATTERNS"); do
                # Convert pattern to shell glob and check
                case "$f" in
                  $pat) ok=true; break;;
                esac
              done
              if [ "$ok" = "false" ]; then
                echo "ERROR: Proposed change touches disallowed path: $f"
                echo "Allowed patterns are:"
                echo "$ALLOWED_PATTERNS"
                exit 1
              fi
            done
            unset IFS

            # Basic safety: disallow creation of files that have no extension unless explicitly allowed
            for f in $files; do
              base=$(basename "$f")
              if [[ "$base" != *.* ]]; then
                # allow certain extensionless filenames explicitly
                case "$base" in
                  Dockerfile|Makefile|README|README.md|LICENSE|.gitattributes) ;;
                  *)
                    echo "ERROR: Proposed change would create/modify extensionless file not on allowlist: $f"
                    exit 1
                esac
              fi
            done

            # Do a dry-run apply check
            if git apply --check fixes1.diff; then
              echo "git apply --check ok. Applying diff..."
              git apply --whitespace=fix fixes1.diff
              # Stage changes
              git add -A
            else
              echo "git apply --check failed; aborting."
              sed -n '1,200p' fixes1.diff || true
              exit 1
            fi
          else
            echo "No AI diff produced (or empty diff)."
          fi

      - name: Build check (capture)
        id: build
        run: |
          set +e
          go build ./... 2>&1 | tee build-output.txt
          echo "BUILD_FAILED=$?" >> $GITHUB_ENV
          set -e

      - name: Truncate build log
        run: head -n 200 build-output.txt > build-trunc.txt || true

      - name: AI pass #2 – fix build errors (optional)
        if: env.OPENROUTER_API_KEY != '' && env.BUILD_FAILED == '1'
        run: |
          PROMPT='Build failed. Fix remaining compilation errors so `go build ./...` succeeds. Return a git-style unified diff.'
          jq -nc --arg model "deepseek/deepseek-r1:free" \
            --arg system "$PROMPT" \
            --arg user "$(jq -Rs . < build-trunc.txt)" \
            '{model:$model, messages:[{role:"system",content:$system},{role:"user",content:$user}],temperature:0.1}' \
            > ai-req2.json

          RESP=$(curl -s -X POST https://openrouter.ai/api/v1/chat/completions \
            -H "Content-Type: application/json" \
            -H "Authorization: Bearer $OPENROUTER_API_KEY" \
            -d @ai-req2.json || true)

          echo "$RESP" | jq -r '.choices[0].message.content // empty' > ai-raw2.txt || true
          sed -n '/^diff --git a\//,$p' ai-raw2.txt > fixes2.diff || true

          if [ -s fixes2.diff ]; then
            echo "Validating AI build-fix diff files..."
            files=$(sed -n 's/^+++ b\///p' fixes2.diff | sed 's/\t.*$//g' | sed '/^$/d' | uniq)
            echo "$files"

            IFS=$'\n'
            for f in $files; do
              ok=false
              for pat in $(echo "$ALLOWED_PATTERNS"); do
                case "$f" in
                  $pat) ok=true; break;;
                esac
              done
              if [ "$ok" = "false" ]; then
                echo "ERROR: Proposed change touches disallowed path: $f"
                exit 1
              fi
            done
            unset IFS

            if git apply --check fixes2.diff; then
              git apply --whitespace=fix fixes2.diff
              git add -A
            else
              echo "git apply --check failed for build-fix; aborting."
              sed -n '1,200p' fixes2.diff || true
              exit 1
            fi
          else
            echo "No AI build-fix diff produced."
          fi

      - name: Final build & tests (ensure success before PR)
        run: |
          go build ./...
          go test ./... -v

      - name: Commit & push changes (if any)
        id: commit
        run: |
          # Only commit if there are staged changes
          if git diff --cached --quiet; then
            echo "No changes to commit."
            echo "CHANGES_PRESENT=false" >> $GITHUB_ENV
          else
            # Create unique branch name
            SHORT=$(git rev-parse --short=8 HEAD)
            BRANCH="ci/auto-update/go-${{ env.LATEST }}-${SHORT}-${{ github.run_id }}"
            git checkout -b "$BRANCH"
            # Commit staged changes
            git commit -m "chore(ci): bump Go ${{ env.LATEST }}, upgrade deps & apply automated fixes" || true
            # Push branch
            git push --set-upstream origin "$BRANCH"
            echo "PUSHED_BRANCH=$BRANCH" >> $GITHUB_ENV
            echo "CHANGES_PRESENT=true" >> $GITHUB_ENV
          fi

      - name: Create Pull Request (only if changes present)
        if: env.CHANGES_PRESENT == 'true'
        uses: peter-evans/create-pull-request@v7.0.8
        with:
          token: ${{ env.GH_TOKEN }}
          commit-message: "chore(ci): bump Go to ${{ env.LATEST }}, upgrade deps & apply automated fixes"
          branch: ${{ env.PUSHED_BRANCH }}
          title: "CI: Go ${{ env.LATEST }} + auto-fix vet/tests/build"
          body: |
            **Automated results**
            - Go version: ${{ env.LATEST }}
            - Vet exit code: ${{ env.VET_FAILED }}
            - Test exit code: ${{ env.TEST_FAILED }}
            - Gosec exit code: ${{ env.SEC_FAILED }}
            - Build exit code: ${{ env.BUILD_FAILED }}
            - AI-generated patches applied (if any)
          labels: automated
          draft: false

      - name: Cleanup temp files
        if: always()
        run: |
          rm -f ai-req*.json ai-raw*.txt fixes*.diff ai-context1.txt \
                vet-output.txt test-output.txt gosec-output.txt \
                vet-trunc.txt test-trunc.txt gosec-trunc.txt \
                build-output.txt build-trunc.txt

