name: CI_Grok4

on:
  workflow_dispatch:
  schedule:
    - cron: '0 2 * * *'

permissions:
  contents: write
  pull-requests: write
  checks: write

concurrency:
  group: ci-grok4
  cancel-in-progress: false

env:
  API_URL: "https://openrouter.ai/api/v1/chat/completions"
  AI_MODEL: "x-ai/grok-4-fast:free"
  OPENROUTER_API_KEY: ${{ secrets.OPENROUTER_API_KEY }}
  GH_TOKEN: ${{ secrets.GH_TOKEN }}

jobs:
  ai-deps:
    runs-on: ubuntu-latest
    env:
      BASE_BRANCH: ${{ github.ref_name }}

    steps:
      - name: Checkout repository (full)
        uses: actions/checkout@v5
        with:
          fetch-depth: 0
          persist-credentials: true

      - name: Configure git
        run: |
          git config user.name "ci-grok4-bot"
          git config user.email "ci-grok4-bot@users.noreply.github.com"

      - name: Set up Go
        uses: actions/setup-go@v6
        with:
          go-version: stable

      - name: Determine Go cache locations
        id: goenv
        run: |
          echo "gomodcache=$(go env GOMODCACHE)" >> $GITHUB_OUTPUT
          echo "gocache=$(go env GOCACHE)" >> $GITHUB_OUTPUT

      - name: Clear existing Go cache directories to avoid tar extract conflicts
        run: |
          set -euxo pipefail

          # Helper to safely remove a directory that may contain root-owned files.
          # Strategy:
          # 1. If dir exists, show owner info for diagnostics.
          # 2. Attempt to change ownership recursively to the current runner user.
          # 3. If chown succeeds, remove as runner user.
          # 4. If chown fails, fall back to sudo rm -rf.
          # This avoids repeated "Permission denied" errors when removing caches restored with root-owned files.
          for dir in "${{ steps.goenv.outputs.gomodcache }}" "${{ steps.goenv.outputs.gocache }}"; do
            if [ -z "$dir" ]; then
              continue
            fi
            if [ ! -e "$dir" ]; then
              echo "Cache path does not exist: $dir"
              continue
            fi

            echo "Preparing to remove cache path: $dir"
            # Show ownership and basic info
            ls -lad "$dir" || true
            stat -c "owner=%u:%g mode=%a" "$dir" || true

            # Attempt to chown recursively to the current runner user; if that works, rm -rf as runner user.
            if sudo chown -R "$(id -u):$(id -g)" "$dir" 2>/dev/null; then
              echo "Successfully changed ownership of $dir to $(id -u):$(id -g). Removing..."
              rm -rf "$dir"
            else
              echo "Failed to chown $dir (permission escalation may be needed). Attempting sudo rm -rf..."
              # Final fallback: remove with sudo; this should succeed on ubuntu-latest hosted runners.
              sudo rm -rf "$dir"
            fi

            # Confirm removal (or warn)
            if [ -e "$dir" ]; then
              echo "Warning: cache path still exists after removal attempt: $dir"
              ls -lad "$dir" || true
            else
              echo "Cache path removed: $dir"
            fi
          done

      - name: Cache Go modules and build cache
        uses: actions/cache@v4.2.4
        with:
          path: |
            ${{ steps.goenv.outputs.gomodcache }}
            ${{ steps.goenv.outputs.gocache }}
          key: ${{ runner.os }}-go-${{ hashFiles('**/go.sum') }}
          restore-keys: |
            ${{ runner.os }}-go-

      - name: Install golangci-lint (recommended action)
        uses: golangci/golangci-lint-action@v8
        with:
          version: v2.5.0

      - name: Ensure scripts are executable
        run: |
          chmod +x .github/scripts/ai_refactor.sh || true
          chmod +x .github/scripts/auto_fix_lints.sh || true

      - name: Run AI refactor (produce ai.patch and artifacts)
        id: run_refactor
        env:
          API_URL: ${{ env.API_URL }}
          AI_MODEL: ${{ env.AI_MODEL }}
          OPENROUTER_API_KEY: ${{ env.OPENROUTER_API_KEY }}
          OPENROUTER_INCLUDE_REASONING: "true"
          OPENROUTER_REASONING_EFFORT: "high"
          # Ensure the script does not push itself; we'll create the PR using the GH_TOKEN secret later.
          GITHUB_TOKEN: ""
        run: |
          set -euo pipefail
          # Run the repository's AI refactor script; it should write ai.patch and relevant artifacts to workspace
          if [ -x .github/scripts/ai_refactor.sh ]; then
            ./.github/scripts/ai_refactor.sh dependencies "${API_URL}" "${AI_MODEL}" || true
          else
            echo "ai_refactor.sh not present or not executable; skipping AI refactor step."
          fi
          ls -lah || true

      - name: Apply AI patch locally (if present)
        id: apply_patch
        run: |
          set -euo pipefail
          if [ -f ai.patch ]; then
            # Dry-run check then apply
            if git apply --check ai.patch; then
              git apply ai.patch
              echo "Applied ai.patch to workspace."
            else
              echo "ai.patch exists but failed git apply --check; saving for artifact and continuing."
              exit 0
            fi
          else
            echo "No ai.patch to apply."
          fi

      - name: Show workspace changes
        if: always()
        run: |
          echo "Git status:"
          git status --porcelain
          echo "Changed files:"
          git --no-pager diff --name-only || true

      - name: Create Pull Request for Go/module changes only
        if: success()
        uses: peter-evans/create-pull-request@v7.0.8
        with:
          token: ${{ env.GH_TOKEN }}
          commit-message: "chore: automated dependency updates and AI refactor"
          title: "chore(deps): Automated dependency updates and AI refactor"
          body: |
            Automated dependency updates and AI-driven refactor were applied by CI. Please review the changes.
          branch: automated-deps
          branch-suffix: timestamp
          delete-branch: true
          add-paths: |
            **/*.go
            go.mod
            go.sum

      - name: Run golangci-lint and capture output
        run: |
          set -euo pipefail
          if golangci-lint run ./... 2>&1 | tee linter.log; then
            echo "golangci-lint completed without fatal errors."
          else
            echo "golangci-lint reported issues; see linter.log."
          fi

      - name: Run tests and capture output
        run: |
          set -euo pipefail
          go test ./... 2>&1 | tee tests.log || true

      - name: Run gofmt check
        run: |
          set -euo pipefail
          gofmt -l . > gofmt.list || true
          if [ -s gofmt.list ]; then
            echo "Files that need gofmt:"
            cat gofmt.list
          fi

      - name: Run gitleaks scan (non-blocking)
        uses: gitleaks/gitleaks-action@v2.3.9
        with:
          args: detect --format json --report-path=gitleaks.json || true
        env:
          GITHUB_TOKEN: ${{ env.GH_TOKEN }}

      - name: Upload CI artifacts
        if: always()
        uses: actions/upload-artifact@v4.6.2
        with:
          name: ci-grok4-artifacts
          path: |
            ai-request.json
            ai-response.json
            ai-response-raw.txt
            ai.patch
            tests.log
            linter.log
            gitleaks.json
            pre-ai.diff
            push.log
            gofmt.list

      - name: Final status
        if: always()
        run: echo "CI_grok4 workflow finished."
