name: CI 3

on:
  schedule:
    - cron: '0 6 * * *'        # Daily at 06:00 UTC
  workflow_dispatch:          # Manual trigger
  pull_request_target:        # Semantic-title enforcement on PRs
    types: [opened, edited, reopened]

permissions:
  contents: write
  pull-requests: write
  issues: write

env:
  OPENROUTER_API_KEY: ${{ secrets.OPENROUTER_API_KEY }}
  GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

jobs:
  update-go:
    name: Update Go, AI-Patch & Auto-Merge
    runs-on: ubuntu-latest
    strategy:
      matrix:
        go-version: 1.24
    env:
      GO_CACHE_DATE: ${{ github.run_id }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Enforce semantic PR title
        if: ${{ github.event_name == 'pull_request' || github.event_name == 'pull_request_target' }}
        uses: amannn/action-semantic-pull-request@v6
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          githubBaseUrl: https://api.github.com

      - name: Set up Go ${{ matrix.go-version }}
        uses: actions/setup-go@v5
        with:
          go-version: ${{ matrix.go-version }}

      - name: Cache Go modules & build cache
        uses: actions/cache@v4
        with:
          path: |
            ~/.cache/go-build
            ~/go/pkg/mod
          key: ${{ runner.os }}-go-${{ matrix.go-version }}-${{ hashFiles('go.sum') }}-${{ env.GO_CACHE_DATE }}
          restore-keys: |
            ${{ runner.os }}-go-${{ matrix.go-version }}-

      - name: Bump go.mod to Go ${{ matrix.go-version }}
        run: sed -i "s/^go .*/go ${{ matrix.go-version }}/" go.mod

      - name: Upgrade dependencies (respect module major & required Go version)
        # This step:
        # 1) finds upgrade candidates (same major version),
        # 2) queries each candidate's GoVersion, and
        # 3) only upgrades those whose Go requirement <= current Go.
        run: |
          set -euo pipefail
          echo "Listing update candidates (go list -m -u -json all)..."
          # Collect candidate lines: "Path CurrentVersion UpdateVersion"
          mapfile -t CANDIDATES < <(go list -m -u -json all 2>/dev/null \
            | jq -r 'select(.Update) | "\(.Path) \(.Version // "") \(.Update.Version // "")"' || true)

          if [ ${#CANDIDATES[@]} -eq 0 ]; then
            echo "No update candidates found."
          else
            echo "Detected ${#CANDIDATES[@]} candidate(s). Filtering by same major version and Go requirement..."
          fi

          # Get current go version (major.minor) from the installed go
          GV_FULL=$(go version | awk '{print $3}' | sed 's/^go//')
          # Ensure we have at least major.minor
          GV_MM=$(echo "${GV_FULL}" | awk -F. '{print $1"."$2}')
          echo "Current Go runtime version: ${GV_FULL} -> major.minor ${GV_MM}"

          # Convert a major.minor string like "1.22" (or "1.23.0") to numeric for comparison: major*1000 + minor
          num_from_mm() {
            local mm="$1"
            local maj=$(echo "$mm" | awk -F. '{print $1}')
            local min=$(echo "$mm" | awk -F. '{print $2+0}')
            echo $((maj * 1000 + min))
          }

          CUR_NUM=$(num_from_mm "${GV_MM}")

          UPGRADES=()
          for line in "${CANDIDATES[@]}"; do
            # read fields defensively (module path may not contain spaces)
            PATH_MOD=$(echo "$line" | awk '{print $1}')
            CURVER=$(echo "$line" | awk '{print $2}')
            UPDVER=$(echo "$line" | awk '{print $3}')
            [ -n "$PATH_MOD" ] || continue
            [ -n "$UPDVER" ] || continue

            # strip leading 'v' for numeric split
            CURMAJ=$(echo "${CURVER}" | sed 's/^v//' | cut -d. -f1)
            UPDMAJ=$(echo "${UPDVER}" | sed 's/^v//' | cut -d. -f1)

            # preserve "no major bumps" policy: the major part (including '0') must match
            if [ "$CURMAJ" != "$UPDMAJ" ]; then
              echo "Skipping $PATH_MOD: would change major from $CURMAJ -> $UPDMAJ"
              continue
            fi

            # Query the module's requested go directive for the update version
            echo "Inspecting $PATH_MOD@$UPDVER for Go version requirement..."
            GOINFO=$(go list -m -json "${PATH_MOD}@${UPDVER}" 2>/dev/null || true)
            REQ_GO=$(printf '%s' "$GOINF O" | jq -r 'select(.) | .GoVersion // empty' 2>/dev/null || true)
            # (The above line uses jq only if GOINFO is JSON; the fallback is empty.)
            if [ -z "$REQ_GO" ]; then
              # If module has no go directive, assume very old/low requirement -> safe
              REQ_GO="1.0"
            fi

            # Normalize to major.minor
            REQ_MM=$(echo "${REQ_GO}" | awk -F. '{print $1"."$2}')
            REQ_NUM=$(num_from_mm "${REQ_MM}")

            if [ "${REQ_NUM}" -gt "${CUR_NUM}" ]; then
              echo "Skipping $PATH_MOD@$UPDVER: requires Go ${REQ_GO} (>= ${REQ_MM}), current=${GV_MM}"
              continue
            fi

            echo "Will upgrade $PATH_MOD to $UPDVER (requires Go ${REQ_GO} - satisfied by ${GV_MM})"
            UPGRADES+=("${PATH_MOD}@${UPDVER}")
          done

          if [ ${#UPGRADES[@]} -eq 0 ]; then
            echo "No safe upgrades to apply for Go ${GV_MM}."
          else
            echo "Applying ${#UPGRADES[@]} upgrade(s)..."
            for m in "${UPGRADES[@]}"; do
              echo "go get -u ${m}"
              go get -u "${m}"
            done
            echo "Tidying modules..."
            go mod tidy
          fi

      - name: Format, vet & lint
        run: |
          set -euo pipefail
          go fix ./...
          go vet ./...
          go fmt ./...
          # install golangci-lint into ./bin reliably and run it (lint failures won't fail the job)
          curl -sSfL https://raw.githubusercontent.com/golangci/golangci-lint/master/install.sh | sh -s latest
          ./bin/golangci-lint run || echo "::warning::Lint issues flagged"

      - name: Run tests with race detector
        id: test
        continue-on-error: true
        run: |
          set -euo pipefail
          go test -race ./... > test_output.txt 2>&1 || true
          if grep -q FAIL test_output.txt; then
            echo "tests_failed=true" >> $GITHUB_OUTPUT
          else
            echo "tests_failed=false" >> $GITHUB_OUTPUT
          fi

      - name: Summarize code changes
        run: |
          set -euo pipefail
          git fetch origin main --tags || true
          git diff origin/main...HEAD > code.diff || true
          {
            echo "## Code Diff Summary"
            echo '```diff'
            head -n 200 code.diff || true
            echo '```'
          } > diff-summary.md

      - name: AI-generated patch via OpenRouter
        if: ${{ steps.test.outputs.tests_failed == 'true' }}
        run: |
          set -euo pipefail
          DIFF=$(head -n 200 code.diff || true)
          ERR=$(head -n 200 test_output.txt || true)
          curl -s https://openrouter.ai/api/v1/chat/completions \
            -H "Authorization: Bearer ${{ secrets.OPENROUTER_API_KEY }}" \
            -H "Content-Type: application/json" \
            -d '{
              "model":"qwen/qwen3-coder:free",
              "messages":[
                {"role":"system","content":"You are a Go refactoring assistant. Given a git diff and test failures, output a patch to fix the code."},
                {"role":"user","content":"Diff:\n'"$DIFF"'\n\nTests:\n'"$ERR"'"}
              ],
              "temperature":0.3,
              "max_tokens":1024
            }' \
            | jq -r '.choices[0].message.content' > patch.diff || echo "::warning::No AI patch returned"

      - name: Apply AI patch
        if: ${{ steps.test.outputs.tests_failed == 'true' }}
        run: |
          set -euo pipefail
          if [ -s patch.diff ]; then
            git apply patch.diff || echo "::warning::AI patch could not be applied"
          else
            echo "::warning::patch.diff is empty; skipping apply"
          fi

      - name: Install git-cliff (robust)
        run: |
          set -euo pipefail
          REPO="orhun/git-cliff"
          API_URL="https://api.github.com/repos/${REPO}/releases/latest"
          echo "Fetching latest release metadata for ${REPO}..."
          RELEASE_JSON=$(curl -sS -H "Accept: application/vnd.github+json" -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" "${API_URL}")

          # Prefer x86_64 linux tar.gz (gnu preferred); fallback to a pinned asset if not found
          DL_URL=$(printf '%s\n' "$RELEASE_JSON" | jq -r '.assets[]?.browser_download_url as $u | .assets[]?.name as $n | "\($n) \($u)"' 2>/dev/null \
            | awk '/(x86_64|amd64).*linux.*(gnu|musl).*\.tar\.gz/ { print $2; exit }' || true)

          if [ -z "$DL_URL" ]; then
            echo "No suitable tar.gz asset found in latest; falling back to v2.10.0 glibc asset"
            DL_URL="https://github.com/orhun/git-cliff/releases/download/v2.10.0/git-cliff-2.10.0-x86_64-unknown-linux-gnu.tar.gz"
          fi

          echo "Downloading: $DL_URL"
          TMP_ARCH="/tmp/git-cliff.tar.gz"
          curl -sSL --retry 3 --retry-delay 2 "$DL_URL" -o "$TMP_ARCH"

          TMP_DIR="/tmp/git-cliff-extract-$$"
          mkdir -p "$TMP_DIR"
          tar -xzf "$TMP_ARCH" -C "$TMP_DIR"

          BIN_PATH=$(find "$TMP_DIR" -type f -name git-cliff -perm /111 -print -quit || true)
          if [ -z "$BIN_PATH" ]; then
            echo "ERROR: git-cliff binary not found inside archive; listing contents for debug:" >&2
            tar -tzf "$TMP_ARCH" >&2 || true
            exit 1
          fi

          sudo install -m 0755 "$BIN_PATH" /usr/local/bin/git-cliff
          echo "git-cliff version: $(/usr/local/bin/git-cliff --version || true)"

      - name: Generate changelog diff with git-cliff
        run: |
          set -euo pipefail
          git fetch --tags || true
          PREV_TAG=$(git describe --tags --abbrev=0 2>/dev/null || true)
          if [ -n "$PREV_TAG" ]; then
            echo "Generating changelog for range: $PREV_TAG..HEAD"
            git-cliff --rev-range "$PREV_TAG..HEAD" --output CHANGELOG.md
          else
            echo "No tags found — generating full changelog"
            git-cliff --output CHANGELOG.md || echo "git-cliff produced no changelog"
          fi
          echo "## Changelog Diff" > changelog.md
          cat CHANGELOG.md >> changelog.md || true

      - name: Prepare PR body file
        run: |
          set -euo pipefail
          TESTS_FAILED="${{ steps.test.outputs.tests_failed }}"
          cat > pr_body.md <<'EOF'
## 🔧 Updates
- Go version → '${{ matrix.go-version }}'
- Dependencies upgraded

## 🧠 Code Diff Summary
$(cat diff-summary.md || true)

## 🤖 AI Patch (if applied)
```diff
$(cat patch.diff || true)
