name: CI3

on:
  schedule:
    - cron: '0 6 * * *'
  workflow_dispatch:
  pull_request_target:
    types: [opened, edited, reopened]

permissions:
  contents: write
  pull-requests: write
  issues: write

env:
  OPENROUTER_API_KEY: ${{ secrets.OPENROUTER_API_KEY }}
  GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

jobs:
  detect-go-versions:
    name: Detect Go versions (latest stable + recent)
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.set-matrix.outputs.matrix }}
    steps:
      - name: Install jq
        run: |
          sudo apt-get update -y
          sudo apt-get install -y jq

      - name: Fetch go.dev list and build matrix
        id: set-matrix
        run: |
          set -euo pipefail

          # fallback matrix if detection fails
          FALLBACK='["1.25","1.24","1.23"]'

          echo "Fetching go.dev release list..."
          TMP_JSON="$(mktemp)"
          if ! curl -sS 'https://go.dev/dl/?mode=json' -o "$TMP_JSON"; then
            echo "::warning::Failed to fetch go.dev JSON; using fallback matrix"
            echo "matrix=$FALLBACK" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          # Extract stable versions as "1.25" "1.24" ... (one-per-line), preserve order
          # Use jq to output .version (like "go1.25.0"), strip leading "go", take major.minor,
          # and dedupe in order using awk seen[].
          mapfile -t VERSIONS_ARR < <(
            jq -r 'map(select(.stable==true)) | .[] | .version' "$TMP_JSON" \
              | sed 's/^go//' \
              | awk -F. '{print $1"."$2}' \
              | awk '!seen[$0]++'
          )

          # build matrix items: latest stable plus up to two previous
          ITEMS=()
          COUNT=0
          for v in "${VERSIONS_ARR[@]}"; do
            [ -n "$v" ] || continue
            ITEMS+=("\"${v}\"")
            COUNT=$((COUNT+1))
            if [ "$COUNT" -ge 3 ]; then
              break
            fi
          done

          # If nothing parsed, fallback
          if [ "${#ITEMS[@]}" -eq 0 ]; then
            echo "::warning::No versions parsed from go.dev; using fallback"
            echo "matrix=$FALLBACK" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          MATRIX_JSON="[${ITEMS[*]}]"
          echo "Detected matrix: $MATRIX_JSON"
          echo "matrix=$MATRIX_JSON" >> "$GITHUB_OUTPUT"
      - name: Cleanup
        if: always()
        run: |
          rm -f "${TMP_JSON:-}" || true

  update-go:
    name: Update Go, deps & auto-PR
    needs: detect-go-versions
    runs-on: ubuntu-latest
    strategy:
      matrix:
        go-version: ${{ fromJson(needs.detect-go-versions.outputs.matrix) }}
    env:
      GO_CACHE_DATE: ${{ github.run_id }}
      OPENROUTER_API_KEY: ${{ secrets.OPENROUTER_API_KEY }}
      GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Install jq (runner may not have it)
        run: |
          sudo apt-get update -y
          sudo apt-get install -y jq

      - name: Set up Go ${{ matrix.go-version }}
        uses: actions/setup-go@v5
        with:
          go-version: ${{ matrix.go-version }}

      - name: Confirm go version
        run: |
          set -euo pipefail
          go version

      - name: Cache Go modules & build cache
        uses: actions/cache@v4
        with:
          path: |
            ~/.cache/go-build
            ~/go/pkg/mod
          key: ${{ runner.os }}-go-${{ matrix.go-version }}-${{ hashFiles('go.sum') }}-${{ env.GO_CACHE_DATE }}
          restore-keys: |
            ${{ runner.os }}-go-${{ matrix.go-version }}-

      - name: Ensure go.mod 'go' directive matches runtime (if present)
        run: |
          set -euo pipefail
          if [ -f go.mod ]; then
            sed -i "s/^go .*/go ${{ matrix.go-version }}/" go.mod
            echo "Updated go.mod 'go' directive to ${{ matrix.go-version }}"
          else
            echo "No go.mod present; skipping go.mod update"
          fi

      - name: Safe dependency upgrades (no major bumps; skip upgrades requiring newer Go)
        run: |
          set -euo pipefail

          echo "Collecting upgrade candidates..."
          mapfile -t CANDS < <(go list -m -u -json all 2>/dev/null \
            | jq -r 'select(.Update) | "\(.Path) \(.Version // "") \(.Update.Version // "")"' || true)

          if [ ${#CANDS[@]} -eq 0 ]; then
            echo "No update candidates."
          fi

          num_from_mm() {
            local mm="$1"
            local maj=$(echo "$mm" | awk -F. '{print $1}')
            local min=$(echo "$mm" | awk -F. '{print $2+0}')
            echo $((maj * 1000 + min))
          }

          GV_FULL=$(go version | awk '{print $3}' | sed 's/^go//')
          GV_MM=$(echo "$GV_FULL" | awk -F. '{print $1"."$2}')
          CUR_NUM=$(num_from_mm "$GV_MM")
          echo "Runtime Go: $GV_FULL (major.minor: $GV_MM)"

          UPGRADES=()
          for L in "${CANDS[@]}"; do
            PATH_MOD=$(echo "$L" | awk '{print $1}')
            CURVER=$(echo "$L" | awk '{print $2}')
            UPDVER=$(echo "$L" | awk '{print $3}')
            [ -n "$PATH_MOD" ] || continue
            [ -n "$UPDVER" ] || continue

            CURMAJ=$(echo "${CURVER}" | sed 's/^v//' | cut -d. -f1)
            UPDMAJ=$(echo "${UPDVER}" | sed 's/^v//' | cut -d. -f1)
            if [ "$CURMAJ" != "$UPDMAJ" ]; then
              echo "Skipping $PATH_MOD: major bump ($CURMAJ -> $UPDMAJ)"
              continue
            fi

            echo "Inspecting ${PATH_MOD}@${UPDVER} for Go requirement..."
            MODJSON=$(go list -m -json "${PATH_MOD}@${UPDVER}" 2>/dev/null || true)
            REQ_GO=$(printf '%s' "$MODJSON" | jq -r '.GoVersion // empty' 2>/dev/null || true)
            if [ -z "$REQ_GO" ]; then
              REQ_GO="1.0"
            fi
            REQ_MM=$(echo "${REQ_GO}" | awk -F. '{print $1"."$2}')
            REQ_NUM=$(num_from_mm "${REQ_MM}")

            if [ "${REQ_NUM}" -gt "${CUR_NUM}" ]; then
              echo "Skipping ${PATH_MOD}@${UPDVER}: requires go ${REQ_GO} (runtime ${GV_MM})"
              continue
            fi

            echo "Will upgrade ${PATH_MOD} -> ${UPDVER} (requires go ${REQ_GO})"
            UPGRADES+=("${PATH_MOD}@${UPDVER}")
          done

          if [ ${#UPGRADES[@]} -eq 0 ]; then
            echo "No safe upgrades to apply."
          else
            for m in "${UPGRADES[@]}"; do
              echo "Applying: go get -u ${m}"
              go get -u "${m}"
            done
            echo "Running go mod tidy"
            go mod tidy
          fi

      - name: Format, vet & lint
        run: |
          set -euo pipefail
          go fix ./... || true
          go vet ./... || true
          go fmt ./... || true
          curl -sSfL https://raw.githubusercontent.com/golangci/golangci-lint/master/install.sh | sh -s latest
          ./bin/golangci-lint run || echo "::warning::Lint issues flagged"

      - name: Run tests (race)
        id: test
        continue-on-error: true
        run: |
          set -euo pipefail
          go test -race ./... > test_output.txt 2>&1 || true
          if grep -q FAIL test_output.txt; then
            echo "tests_failed=true" >> "$GITHUB_OUTPUT"
          else
            echo "tests_failed=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Summarize code changes
        run: |
          set -euo pipefail
          git fetch origin main --tags || true
          git diff origin/main...HEAD > code.diff || true
          {
            echo "## Code Diff Summary"
            echo '```diff'
            head -n 200 code.diff || true
            echo '```'
          } > diff-summary.md

      - name: Optional AI-generated patch (OpenRouter)
        if: ${{ steps.test.outputs.tests_failed == 'true' }}
        run: |
          set -euo pipefail
          DIFF=$(head -n 200 code.diff || true)
          ERR=$(head -n 200 test_output.txt || true)
          curl -s https://openrouter.ai/api/v1/chat/completions \
            -H "Authorization: Bearer ${{ secrets.OPENROUTER_API_KEY }}" \
            -H "Content-Type: application/json" \
            -d '{
              "model":"qwen/qwen3-coder:free",
              "messages":[
                {"role":"system","content":"You are a Go refactoring assistant. Given a git diff and test failures, output a patch to fix the code."},
                {"role":"user","content":"Diff:\n'"$DIFF"'\n\nTests:\n'"$ERR"'"}
              ],
              "temperature":0.3,
              "max_tokens":1024
            }' \
            | jq -r '.choices[0].message.content' > patch.diff || echo "::warning::No AI patch returned"

      - name: Apply AI patch
        if: ${{ steps.test.outputs.tests_failed == 'true' }}
        run: |
          set -euo pipefail
          if [ -s patch.diff ]; then
            git apply patch.diff || echo "::warning::AI patch could not be applied"
          else
            echo "::warning::patch.diff empty; skipping"
          fi

      - name: Install git-cliff (robust)
        run: |
          set -euo pipefail
          REPO="orhun/git-cliff"
          API_URL="https://api.github.com/repos/${REPO}/releases/latest"
          RELEASE_JSON=$(curl -sS -H "Accept: application/vnd.github+json" -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" "${API_URL}" || true)

          DL_URL=$(printf '%s' "$RELEASE_JSON" | jq -r '.assets[]? | select(.name|test("linux.*(gnu|musl).*tar.gz")) | .browser_download_url' 2>/dev/null | head -n1 || true)
          if [ -z "$DL_URL" ]; then
            echo "::warning::No suitable latest asset found; falling back to pinned v2.10.0"
            DL_URL="https://github.com/orhun/git-cliff/releases/download/v2.10.0/git-cliff-2.10.0-x86_64-unknown-linux-gnu.tar.gz"
          fi

          TMP_ARCH="/tmp/git-cliff.tar.gz"
          curl -sSL --retry 3 --retry-delay 2 "$DL_URL" -o "$TMP_ARCH"
          TMP_DIR="/tmp/git-cliff-extract-$$"
          mkdir -p "$TMP_DIR"
          tar -xzf "$TMP_ARCH" -C "$TMP_DIR"
          BIN_PATH=$(find "$TMP_DIR" -type f -name git-cliff -perm /111 -print -quit || true)
          if [ -z "$BIN_PATH" ]; then
            echo "tar contents (for debug):"
            tar -tzf "$TMP_ARCH" || true
            echo "::error::git-cliff binary not found in archive"
            exit 1
          fi
          sudo install -m 0755 "$BIN_PATH" /usr/local/bin/git-cliff
          /usr/local/bin/git-cliff --version || true

      - name: Generate changelog with git-cliff
        run: |
          set -euo pipefail
          git fetch --tags || true
          PREV_TAG=$(git describe --tags --abbrev=0 2>/dev/null || true)
          if [ -n "$PREV_TAG" ]; then
            git-cliff --rev-range "$PREV_TAG..HEAD" --output CHANGELOG.md || true
          else
            git-cliff --output CHANGELOG.md || true
          fi
          echo "## Changelog Diff" > changelog.md
          cat CHANGELOG.md >> changelog.md || true

      - name: Prepare PR body file
        run: |
          set -euo pipefail

          GO_VER="${{ matrix.go-version }}"
          TF="${{ steps.test.outputs.tests_failed }}"

          # start fresh
          : > pr_body.md

          # Header + basic info
          printf '%s\n' "## 🔧 Updates" "- Go version → ${GO_VER}" "- Dependencies upgraded (safe upgrades only)" "" >> pr_body.md

          # Code diff summary (if present)
          printf '%s\n' "## 🧠 Code Diff Summary" >> pr_body.md
          if [ -f diff-summary.md ]; then
            cat diff-summary.md >> pr_body.md
          else
            printf '%s\n' "_No diff summary available._" >> pr_body.md
          fi
          printf '\n' >> pr_body.md

          # AI patch section
          printf '%s\n' "## 🤖 AI Patch (if applied)" '```diff' >> pr_body.md
          if [ -f patch.diff ] && [ -s patch.diff ]; then
            cat patch.diff >> pr_body.md
          else
            printf '%s\n' "_No AI patch returned or patch.diff empty._" >> pr_body.md
          fi
          printf '%s\n\n' '```' >> pr_body.md

          # Changelog
          printf '%s\n' "## 📜 Changelog Diff" >> pr_body.md
          if [ -f changelog.md ]; then
            cat changelog.md >> pr_body.md
          else
            printf '%s\n' "_No changelog generated._" >> pr_body.md
          fi
          printf '\n' >> pr_body.md

          # Test status
          printf '%s\n' "## ✅ Test Status" >> pr_body.md
          if [ "${TF:-false}" = "true" ]; then
            printf '%s\n' "❌ Tests failed — see test_output.txt and patch.diff" >> pr_body.md
          else
            printf '%s\n' "✅ All tests passed" >> pr_body.md
          fi

      - name: Create Pull Request
        id: create_pr
        uses: peter-evans/create-pull-request@v7.0.8
        with:
          commit-message: "chore: bump Go to ${{ matrix.go-version }} + deps"
          title: "chore: bump Go to ${{ matrix.go-version }} + deps"
          body-path: pr_body.md
          branch: update/go-${{ matrix.go-version }}
          labels: |
            maintenance
            automated-update
            ${{ steps.test.outputs.tests_failed == 'true' && 'needs-review' || 'safe-update' }}

      - name: Enable auto-merge on passing PR
        if: ${{ steps.test.outputs.tests_failed == 'false' }}
        uses: peter-evans/enable-pull-request-automerge@v3
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          pull-request-number: ${{ steps.create_pr.outputs.pull-request-number }}
          merge-method: squash

      - name: Create fallback issue (if tests failed and AI patch couldn't apply)
        if: ${{ steps.test.outputs.tests_failed == 'true' }}
        uses: peter-evans/create-issue-from-file@v5.0.1
        with:
          title: "⚠️ Go update caused test failures — needs manual review"
          content-filepath: test_output.txt
          labels: |
            bug
            needs-manual-review
