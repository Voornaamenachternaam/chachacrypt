To address the gosec security findings, here's the unified diff:

```diff
diff --git a/chachacrypt.go b/chachacrypt.go
--- a/chachacrypt.go
+++ b/chachacrypt.go
@@ -4,6 +4,8 @@
 	"crypto/rand"
 	"encoding/binary"
 	"errors"
+	"fmt"
+	"math"
 	"os"
 	"path/filepath"
 	"runtime"
@@ -48,7 +50,11 @@
 	}
 
 	return &Params{
-		KeyMemory:  defaultKeyMemory,
-		KeyThreads: uint8(threads),
+		KeyMemory: defaultKeyMemory,
+		KeyThreads: func() uint8 {
+			// Ensure threads is within uint8 range
+			return uint8(max(1, min(threads, math.MaxUint8)))
+		}(),
 		ChunkSize:  defaultChunkSize,
 	}, nil
 }
@@ -202,7 +208,7 @@
 func encryptFile(inputFile, outputFile string, key []byte, params *Params) error {
 	var err error
 
-	inFile, err := os.Open(inputFile)
+	inFile, err := os.Open(filepath.Clean(inputFile))
 	if err != nil {
 		return err
 	}
@@ -208,7 +214,7 @@
 	}
 	defer inFile.Close()
 
-	outFile, err := os.Create(outputFile)
+	outFile, err := os.Create(filepath.Clean(outputFile))
 	if err != nil {
 		return err
 	}
@@ -270,7 +276,7 @@
 func decryptFile(inputFile, outputFile string, key []byte, params *Params) error {
 	var err error
 
-	inFile, err := os.Open(inputFile)
+	inFile, err := os.Open(filepath.Clean(inputFile))
 	if err != nil {
 		return err
 	}
@@ -276,7 +282,7 @@
 	}
 	defer inFile.Close()
 
-	outFile, err := os.Create(outputFile)
+	outFile, err := os.Create(filepath.Clean(outputFile))
 	if err != nil {
 		return err
 	}
@@ -334,6 +340,9 @@
 	if err != nil {
 		return 0, err
 	}
+	if n < 0 || n > math.MaxUint32 {
+		return 0, fmt.Errorf("read length %d exceeds uint32 range", n)
+	}
 	return uint32(n), nil
 }
 
diff --git a/go.mod b/go.mod
--- a/go.mod
+++ b/go.mod
@@ -3,3 +3,5 @@
 module chachacrypt
 
 go 1.19
+
+require golang.org/x/crypto v0.17.0
```

Key changes:
1. Added bounds checking for uint8 conversion of threads parameter
2. Added file path sanitization using filepath.Clean for all file operations
3. Added bounds checking for uint32 conversion when reading chunk sizes
4. Added explicit error handling for overflow scenarios
5. Added missing math package import
6. Added explicit dependency on golang.org/x/crypto

The min/max functions help ensure integer values stay within type boundaries. File path cleaning helps mitigate path traversal vulnerabilities.
